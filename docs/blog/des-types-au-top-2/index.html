<!DOCTYPE html><html lang="en"><head><link rel="preload" href="content.json" as="fetch" crossorigin=""><base href="../../"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><script>if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker.register("service-worker.js");
        });
      } else {
        console.log("No service worker registered.");
      }</script><link rel="shortcut icon" href="assets/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="assets/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="48x48" href="assets/favicon-48x48.png"><link rel="manifest" href="assets/manifest.json"><meta name="mobile-web-app-capable" content="yes"><meta name="theme-color" content="#ffffff"><meta name="application-name" content="Jordane Grenat | Personal Website"><link rel="apple-touch-icon" sizes="57x57" href="assets/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="assets/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="assets/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="assets/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="assets/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="assets/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="assets/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="assets/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="167x167" href="assets/apple-touch-icon-167x167.png"><link rel="apple-touch-icon" sizes="180x180" href="assets/apple-touch-icon-180x180.png"><link rel="apple-touch-icon" sizes="1024x1024" href="assets/apple-touch-icon-1024x1024.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="Jordane Grenat | Personal Website"><script defer="defer" src="main.js"></script><link rel="preload" href="main.js" as="script"><style>/*

Dracula Theme v1.2.0

https://github.com/zenorocha/dracula-theme

Copyright 2015, All rights reserved

Code licensed under the MIT license
http://zenorocha.mit-license.org

@author Éverton Ribeiro <nuxlli@gmail.com>
@author Zeno Rocha <hi@zenorocha.com>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #282a36;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-section,
.hljs-link {
  color: #8be9fd;
}

.hljs-function .hljs-keyword {
  color: #ff79c6;
}

.hljs,
.hljs-subst {
  color: #f8f8f2;
}

.hljs-string,
.hljs-title,
.hljs-name,
.hljs-type,
.hljs-attribute,
.hljs-symbol,
.hljs-bullet,
.hljs-addition,
.hljs-variable,
.hljs-template-tag,
.hljs-template-variable {
  color: #f1fa8c;
}

.hljs-comment,
.hljs-quote,
.hljs-deletion,
.hljs-meta {
  color: #6272a4;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-title,
.hljs-section,
.hljs-doctag,
.hljs-type,
.hljs-name,
.hljs-strong {
  font-weight: bold;
}

.hljs-emphasis {
  font-style: italic;
}
</style><style>@import url(https://fonts.googleapis.com/css?family=Rubik|Noto+Sans&display=swap);</style><style>/***** CSS Reset *******/

/* http://meyerweb.com/eric/tools/css/reset/
   v2.0 | 20110126
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed,
figure, figcaption, footer, header, hgroup,
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
}

/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure,
footer, header, hgroup, menu, nav, section {
  display: block;
}

body {
  line-height: 1;
}

ol, ul {
  list-style: none;
}

blockquote, q {
  quotes: none;
}

blockquote:before, blockquote:after,
q:before, q:after {
  content: '';
  content: none;
}

table {
  border-collapse: collapse;
  border-spacing: 0;
}

* {
  box-sizing: border-box;
}

a {
  text-decoration: none;
  color: inherit;
}

li {
  line-height: 1.9rem;
}

body {
  /* Permalink - use to edit and share this gradient: https://colorzilla.com/gradient-editor/#f5f5f5+0,ffffff+50,64b4fa+51,64b4fa+100 */
  background: #f5f5f5; /* Old browsers */
  background: -moz-linear-gradient(-45deg, #f5f5f5 0%, #ffffff 50%, #64b4fa 50%, #64b4fa 100%); /* FF3.6-15 */
  background: -webkit-linear-gradient(-45deg, #f5f5f5 0%, #ffffff 50%, #64b4fa 50%, #64b4fa 100%); /* Chrome10-25,Safari5.1-6 */
  background: linear-gradient(135deg, #f5f5f5 0%, #ffffff 50%, #64b4fa 50%, #64b4fa 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#f5f5f5', endColorstr='#64b4fa', GradientType=1); /* IE6-9 fallback on horizontal gradient */
  background-attachment: fixed;
}


/* Workaround for hljs */

pre code {
  max-width: 100%;
  font-size: 0.95rem;
  line-height: 1.4rem;
  display: block;
  overflow-x: auto;
  overflow-y: auto;
  padding: 0.5em;
  background: #282a36;
  color: #f8f8f2;
  white-space: pre-wrap;
}

figure > figcaption {
  font-size: 0.8rem;
  line-height: normal;
  font-style: italic;
  text-align: center;
}
</style><title>Des types au top (2)</title><meta name="generator" content="elm-pages v1.3.0"><link rel="canonical" href="https://www.grenat.eu/blog/des-types-au-top-2"><meta name="description" content="Après ce premier article sur les types, découvrons maintenant les possibilités plus avancées d'un système de types : du type unitaire aux dependents types, tout en passant par les phantom types, voyons ensemble leurs avantages !"><meta property="og:image" content="https://www.grenat.eu/images/article-covers/types-2.jpg"><meta property="og:image:secure_url" content="https://www.grenat.eu/images/article-covers/types-2.jpg"><meta property="og:image:alt" content="Après ce premier article sur les types, découvrons maintenant les possibilités plus avancées d'un système de types : du type unitaire aux dependents types, tout en passant par les phantom types, voyons ensemble leurs avantages !"><meta property="og:title" content="Des types au top (2)"><meta property="og:url" content="https://www.grenat.eu/blog/des-types-au-top-2"><meta property="og:description" content="Après ce premier article sur les types, découvrons maintenant les possibilités plus avancées d'un système de types : du type unitaire aux dependents types, tout en passant par les phantom types, voyons ensemble leurs avantages !"><meta property="og:site_name" content="Jordane Grenat | Personal Website"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:title" content="Des types au top (2)"><meta property="twitter:description" content="Après ce premier article sur les types, découvrons maintenant les possibilités plus avancées d'un système de types : du type unitaire aux dependents types, tout en passant par les phantom types, voyons ensemble leurs avantages !"><meta property="twitter:image" content="https://www.grenat.eu/images/article-covers/types-2.jpg"><meta property="twitter:image:alt" content="Après ce premier article sur les types, découvrons maintenant les possibilités plus avancées d'un système de types : du type unitaire aux dependents types, tout en passant par les phantom types, voyons ensemble leurs avantages !"><meta property="og:type" content="article"><meta property="article:published_time" content="2020-02-11"></head><body><div data-url="http://localhost:8000/blog/des-types-au-top-2" display="none"></div><div class="_21dae779"><style>._21dae779 {
    height:100%;
}</style><style>html {
    height:100%;
}

body {
    height:100%;
    font-size:calc(16px + 0.2vw);
    font-family:Noto Sans, sans-serif;
}

h1 {
    font-family:Rubik, serif;
    font-size:calc(1.6rem + 2vw);
    text-align:center;
    margin-bottom:5vh;
    margin-top:1vw;
}

h2 {
    font-size:calc(1.2rem + 1vw);
    text-align:center;
    margin-bottom:3vh;
    font-weight:900;
}

.opaquePanel {
    display:block;
    background-color:rgba(255, 255, 255, 0.95);
    padding:5vh 3vw;
    max-width:900px;
    width:95%;
    margin:3vh auto;
    box-shadow:0 1px 5px 1px rgba(0, 0, 0, 0.4);
}

@media only screen and (max-width: 500px) {
    .opaquePanel {
        width:100%;
    }
}</style><div class="article"><style>.article {
    margin-top:20px;
}

.article  .article-header {
    display:flex;
    flex-wrap:wrap;
    justify-content:space-between;
    align-items:center;
    margin-bottom:2vh;
}

.article  .authorCard {
    display:flex;
    align-items:center;
    flex-grow:1;
    justify-content:flex-end;
}

.article  .authorCard-name {
    text-align:right;
    font-size:1.5rem;
    margin-bottom:1vh;
}

.article  .authorCard-biography {
    text-align:right;
    font-size:1rem;
    color:rgba(0, 0, 0, 0.7);
}

.article  .authorCard-picture {
    width:5rem;
    border-radius:50%;
    margin-left:0.9vw;
}

.article  .backLink {
    display:inline-flex;
    align-items:center;
    padding:5px;
}

.article  .backLink:hover {
    background-color:#64b4fa;
}

.article  .article-title {
    margin-bottom:2vh;
}

.article  .article-publicationDate {
    display:block;
    font-size:0.95rem;
    text-align:center;
    margin-bottom:3vh;
}

.article  .article-coverPhoto {
    width:calc(100% + 6vw);
    margin:0 -3vw 3vh;
}

.article  .article-coverPhoto > img {
    width:100%;
}

.article  .article-coverPhoto-legend {
    font-size:0.9rem;
    color:rgba(0, 0, 0, 0.7);
    text-align:center;
}

.article  .article-coverPhoto-legend > a {
    text-decoration:underline;
}

.article  .article-coverPhoto-legend > a:hover {
    color:rgb(0, 0, 0);
}

.article  .markdown {
    margin-bottom:5vh;
}

.article  .markdown  h2 {
    font-size:2.5rem;
    font-weight:900;
    text-align:left;
    margin:4vh 0 2vh;
}

.article  .markdown  h3 {
    font-size:1.8rem;
    font-weight:600;
    text-align:left;
    margin:3vh 0 1vh;
    color:rgba(0, 0, 0, 0.8);
}

.article  .markdown  p {
    margin:2.5vh 0;
    line-height:1.7rem;
    white-space:pre-wrap;
    text-align:justify;
}

.article  .markdown  p > code {
    background-color:rgba(225, 225, 255, 0.7);
    padding:1px 3px;
    font-size:0.7em;
}

.article  .markdown  blockquote {
    border-left:5px solid rgba(5, 117, 230, 0.8);
    background-color:rgba(5, 117, 230, 0.1);
    padding:0.01vh 1vw;
    margin-left:0.5vw;
    margin-right:0.5vw;
}

.article  .markdown  a {
    text-decoration:underline;
}

.article  .markdown  a:hover {
    text-decoration:none;
}

.article  .markdown  .thanks {
    margin-top:2vw;
    font-style:italic;
    font-size:0.8em;
    text-align:right;
}

.article  .markdown  ul {
    list-style-type:disc;
    padding-left:1rem;
    margin-left:2vh;
}

.article  .markdown  ul > li + li {
    margin-top:2vh;
}</style><div class="opaquePanel"><div class="article-header"><a class="backLink" href="/blog"><svg version="1.1" class="octicon arrowLeft" width="30" height="30" viewBox="0 0 10 16"><polygon points="6 3 0 8 6 13 6 10 10 10 10 6 6 6" fill-rule="evenodd" fill="black"></polygon></svg>Other articles</a><aside class="authorCard"><div><div class="authorCard-name">Jordane Grenat</div><p class="authorCard-biography">Web developer and software craftsman</p></div><img src="images/author/jordane.jpeg" alt="Jordane Grenat" class="authorCard-picture"></aside></div><h1 class="article-title">Des types au top (2)</h1><time class="article-publicationDate" datetime="2020-02-11">February 11th, 2020</time><figure class="article-coverPhoto"><img src="images/article-covers/types-2.jpg" alt="Article cover photo"></figure><div class="markdown"><div><div><p>Dans <a href="/blog/des-types-au-top">mon premier article sur les types</a>, nous avons vu plusieurs notions : la <strong>cardinalité</strong> d'un type correspond au nombre de valeurs possibles de ce type, les <strong>types algébriques</strong> correspondent au fait de pouvoir <em>multipler</em> et <em>additionner</em> les types entre eux (et donc leur cardinalité). </p>
<p>Nous allons voir dans cet article des notions plus avancées pour voir comment on peut jouer avec les types dans nos programmes.</p>
<h2 id="le-type-unitaire">Le type unitaire</h2>
<p>Jusqu'à maintenant, on a réussi à créer des types avec un nombre précis de valeurs possibles grâce aux enums. Par exemple, notre type <code>CardValue</code> contenait 13 valeurs possibles :</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Value {  
  ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING;  
}
</code></pre>
<p>De même, nous connaissons le type <code>bool</code> qui possède une cardinalité de 2 et <em>pourrait</em> être représenté par un enum également :</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Bool {  
  TRUE, FALSE; 
}
</code></pre>
<p>Allons plus loin, et créons un type de cardinalité 1 : </p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Unit {  
  UNIT; 
}
</code></pre>
<p>A quoi peut donc nous servir un type contenant une seule valeur ? Intuitivement, on pourrait penser que cela n'a aucune utilité : une variable de ce type ne peut contenir que cette valeur et est donc constante. On peut en réalité trouver plusieurs cas d'utilisation !</p>
<h3 id="repr-senter-le-rien-">Représenter le "rien"</h3>
<p>Premièrement, imaginons qu'on utilise un <a href="./des-types-au-top#des-applications-d-exception">Result</a> pour obtenir le résultat d'une opération. Sauf que cette opération ne retourne aucun résultat, juste l'information selon laquelle tout s'est bien déroulé <em>ou</em> une erreur indiquant ce qui s'est mal déroulé.</p>
<p>On pourrait donc utiliser le type <code>Result&lt;String, Error&gt;</code> en retournant tout le temps une chaîne de caractère vide, mais ce serait <em>mentir</em> sur notre interface. On peut alors plutôt choisir de retourner le type unitaire que nous avons créé : <code>Result&lt;Unit, Error&gt;</code>. L'appelant sait directement que le cas du succès ne contient aucune information exploitable autre que le fait que notre opération soit un succès.</p>
<blockquote>
<p>Attention ! Dans beaucoup de langages, le type unitaire est un type déjà défini et est représenté comme un tuple vide : <code>()</code>. On écrirait ainsi plutôt <code>Result&lt;(), Error&gt;</code>. Je vais donc utiliser <code>()</code> dans la suite de cet article.</p>
</blockquote>
<p>Ce cas d'utilisation est très proche du <code>Void</code> dans des langages comme Java, dont la seule valeur possible est la valeur joker <code>null</code>. On peut donc s'en servir généralement pour indiquer qu'une fonction ne retourne rien. Rappelez-vous, <code>null</code> n'existe pas dans certains langages et le type algébrique <code>Maybe</code> qui remplace certains de ses cas d'utilisation sert à caractériser une fonction qui retourne <em>parfois</em> des valeurs et <em>parfois</em> rien. Ici, avec <code>Void</code>, on parle de fonctions qui ne renvoient <em>jamais</em> de valeur.</p>
<h3 id="une-fonction-sans-arguments">Une fonction sans arguments</h3>
<p>Dans les langages fonctionnels, les fonctions sans argument sont généralement des constantes, par exemple en Elm :</p>
<pre><code class="lang-elm"><span class="hljs-title">myValue</span> = <span class="hljs-number">13</span>
</code></pre>
<p>Les fonctions sont pures et retournent donc toujours la même valeur quand on leur donne les mêmes arguments. Ce qui explique pourquoi une fonction sans argument est une constante !</p>
<p>Ici, on assigne la valeur 13 à notre variable / constante <code>myValue</code>. Comme <code>13</code> est une valeur facile à calculer,  il n'y a aucun problème. Mais que se passe-t-il si la valeur de <code>myValue</code> est quelque chose de long ou coûteux à calculer ? Dans ce cas-là, on va chercher à la calculer seulement quand on en a besoin. De faire ce qu'on appelle du <code>lazy</code>.</p>
<p>Et pour ça, la solution la plus simple est de mettre un argument qui ne sert à rien :</p>
<pre><code class="lang-elm"><span class="hljs-title">myValue</span> : () -&gt; <span class="hljs-type">Int</span>
<span class="hljs-title">myValue</span> () = <span class="hljs-number">13</span> <span class="hljs-comment">-- remplacer par un calcul long à effectuer</span>

<span class="hljs-comment">-- On calcule cette valeur seulement quand on en a besoin :</span>
<span class="hljs-title">myOtherValue</span> = myValue ()
</code></pre>
<h3 id="repr-senter-les-entiers-naturels">Représenter les entiers naturels</h3>
<p>Cet usage est plus exotique, mais on pourrait s'en servir pour représenter une liste d'entier naturels, à savoir ici  <code>0, 1, 2, 3, 4...</code>. Ce n'est en général pas possible dans les langages de programmation ne possédant pas de type <code>unsigned int</code>.</p>
<p>Alors comment faire ? Imaginons que nous mettions notre type unitaire dans une liste (<code>List&lt;()&gt;</code>), on pourrait donc avoir une liste <code>[(), ()]</code> ou <code>[(), (), (), ()]</code> ou même une liste vide <code>[]</code>. Comme chaque élément de cette liste est forcément le type unitaire, la seule information que cette liste peut nous donner, c'est sa <em>taille</em>. Or, la taille d'une liste est précisément une liste d'entier naturels du type <code>0, 1, 2, 3, 4...</code>. </p>
<p>On pourrait donc implémenter un type basé sur une liste du type unitaire qui nous garantirait d'avoir uniquement des entiers positifs ou zéro ! </p>
<p>Dans la réalité, on utilise plutôt un type algébrique pour représenter les entiers naturels :</p>
<pre><code class="lang-elm"><span class="hljs-keyword">type</span> <span class="hljs-type">NaturalInt</span> = 
  <span class="hljs-type">Zero</span>
  | <span class="hljs-type">Succ</span> <span class="hljs-type">NaturalInt</span>

<span class="hljs-title">zero</span> = <span class="hljs-type">Zero</span>
<span class="hljs-title">one</span> = <span class="hljs-type">Succ</span> <span class="hljs-type">Zero</span>
<span class="hljs-title">two</span> = <span class="hljs-type">Succ</span> (<span class="hljs-type">Succ</span> <span class="hljs-type">Zero</span>)
<span class="hljs-comment">-- ...</span>
</code></pre>
<h2 id="le-type-vide">Le type vide</h2>
<p>Un type avec une cardinalité de 1 peut donc nous être utile, mais qu'en est-il d'un type de cardinalité 0, qui ne possède donc aucune valeur ? Étonnamment, ce genre de type a également des utilités ! Mais voyons comment définir ce genre de type en Haskell :</p>
<pre><code class="lang-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Void</span></span>
</code></pre>
<p>On définit ici un type algébrique sans aucune valeur possible. En Elm, cette  syntaxe n'est pas possible, on a donc recours à une petite astuce pour créer le type vide <code>Never</code> :</p>
<pre><code class="lang-elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Never</span> = <span class="hljs-type">JustOneMore</span> <span class="hljs-type">Never</span>
</code></pre>
<p>On a donc bien un constructeur présent (<code>JustOneMore</code>), mais celui-ci contient un <code>Never</code>, on doit donc lui donner une valeur en utilisant le constructeur <code>JustOneMore</code> qui doit lui-même contenir un <code>Never</code>. On entre dans une récursion infinie et il est donc impossible de créer une valeur de ce type.</p>
<h3 id="le-cas-impossible">Le cas impossible</h3>
<p>Mais alors quelle peut être l'utilité de ce type qu'on ne peut pas utiliser ? Eh bien justement de démontrer que quelque chose est impossible !</p>
<p>Imaginons que notre fonction retourne un <code>Result</code> pour une raison précise (pour se conformer à une interface par exemple) mais que cette fonction ne peut pas échouer (il n'y a aucun cas d'erreur possible). On pourrait signifier que ce résultat est forcément valide en utilisant <code>Result&lt;MyResult, Void&gt;</code>. Comme il est impossible de créer une valeur de type <code>Void</code>, le résultat sera forcément toujours de type <code>Ok MyResult</code>. Notre certitude est donc prouvée par notre système de type et vérifiée par le compilateur.</p>
<h3 id="ne-m-attendez-pas-">Ne m'attendez pas !</h3>
<p><code>Void</code> peut également être utilisé en retour de fonction, avec une conséquence inéluctable : cette fonction ne peut jamais retourner de valeur ! La fonction ne peut donc pas se terminer de la fonction habituelle. Dans certains langages, cela peut vouloir dire que la fonction a une autre façon de se terminer (renvoyer une exception par exemple). Mais cela peut aussi vouloir dire que cette fonction ne va jamais se terminer (boucle infinie) ! On pourrait ainsi représenter une fonction chargée de calculer une à une les décimales de pi en les affichant au fur et à mesure. Comme il y en a une infinité, cette fonction ne se terminerait jamais ! </p>
<p>L'utilisation du type vide peut donc être une indication de boucle infinie volontaire. Le type porte ainsi une information supplémentaire sur notre programme qui est vérifiée par le compilateur.</p>
<h2 id="les-types-fant-mes">Les types fantômes</h2>
<p>Le type vide peut également être utilisé pour d'autres usages : les types fantômes – <em>phantom types</em> en anglais. Ce terme fait référence à des paramètre de types non utilisés dans la définition du type. Un exemple sera plus parlant. Ici, nous avons un type <code>PasswordInput</code> utilisé pour stocker le password saisi par un utilisateur dans un formulaire lorsqu'il veut s'enregistrer sur notre site. L'exemple est en Elm :</p>
<pre><code class="lang-elm"><span class="hljs-keyword">type</span> <span class="hljs-type">PasswordInput</span> a = <span class="hljs-type">Value</span> <span class="hljs-type">String</span>
</code></pre>
<p>On passe en paramètre de la définition de notre type un type <code>a</code> qu'on n'utilise pas dans la définition à droite. Mais alors à quoi sert-il ? Eh bien cela devient très utile lorsqu'on n'expose pas directement le constructeur <code>Value</code> et qu'on expose à la place une fonction <code>createInputValue</code>. Cette fonction est donc la seule façon de créer un <code>PasswordInput</code> :</p>
<pre><code class="lang-elm"><span class="hljs-keyword">type</span> <span class="hljs-type">NotValidated</span> = <span class="hljs-type">NotValidated</span>
<span class="hljs-keyword">type</span> <span class="hljs-type">Validated</span> = <span class="hljs-type">Validated</span>

<span class="hljs-title">createInputValue</span> : <span class="hljs-type">String</span> -&gt; <span class="hljs-type">PasswordInput</span> <span class="hljs-type">NotValidated</span>
<span class="hljs-title">createInputValue</span> value =
    <span class="hljs-type">Value</span> value
</code></pre>
<p>Ici, <code>NotValidated</code> et <code>Validated</code> sont deux types unitaires qui ne vont être utilisés que dans nos signatures de type pour <strong>taguer</strong> notre type, indiquant s'il a été validé ou non. Ici, on crée un <code>PasswordInput NotValidated</code>, notre type de retour comporte donc l'information que cet input n'a pas été validé. Comme ces deux types sont là uniquement pour les signatures de type et non pour leurs valeurs, on peut expliciter ce fait en les rendant non instanciables grâce au type vide <code>Never</code>:</p>
<pre><code class="lang-elm"><span class="hljs-keyword">type</span> <span class="hljs-type">NotValidated</span> = <span class="hljs-type">NotValidated</span> <span class="hljs-type">Never</span>
<span class="hljs-keyword">type</span> <span class="hljs-type">Validated</span> = <span class="hljs-type">Validated</span> <span class="hljs-type">Never</span>
</code></pre>
<p>Créant maintenant une fonction de validation dont le but sera de modifier ce <em>tag</em> si l'input est valide :</p>
<pre><code class="lang-elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Error</span> = <span class="hljs-type">InvalidPassword</span>

<span class="hljs-title">validatePassword</span> : <span class="hljs-type">PasswordInput</span> <span class="hljs-type">NotValidated</span> -&gt; <span class="hljs-type">Result</span> <span class="hljs-type">Error</span> (<span class="hljs-type">PasswordInput</span> <span class="hljs-type">Validated</span>)
<span class="hljs-title">validatePassword</span> (<span class="hljs-type">Value</span> password) =
    <span class="hljs-keyword">if</span> isValid password <span class="hljs-keyword">then</span>
        <span class="hljs-type">Ok</span> (<span class="hljs-type">Value</span> password)
    <span class="hljs-keyword">else</span>
        <span class="hljs-type">Err</span> <span class="hljs-type">InvalidPassword</span>
</code></pre>
<p>La fonction <code>validatePassword</code> permet de modifier le tag si le password est valide ou de retourner une erreur dans le cas inverse. Elle prend également en argument un password tagué <code>NotValidated</code> : avec un email identifié comme <code>Validated</code>, on ne pourrait pas utiliser cette fonction. Cette vérification se fait <em>au moment de la compilation</em>.</p>
<p>On peut noter qu'on ne change en rien la <em>valeur</em> de notre input, mais uniquement son <em>type</em>, qui agit donc en marqueur pour savoir s'il a été validé.</p>
<p>Enfin, voici la signature de la fonction permettant l'enregistrement du mot de passe côté backend :</p>
<pre><code class="lang-elm"><span class="hljs-title">saveNewPassword</span> : <span class="hljs-type">PasswordInput</span> <span class="hljs-type">Validated</span> -&gt; <span class="hljs-type">Cmd</span> <span class="hljs-type">Msg</span>
</code></pre>
<p>Comme on le voit, on peut ici inscrire dans notre système de type que notre password est bien valide, donc qu'il a passé avec succès la phase de validation de <code>validatePassword</code>. Et puisque le compilateur va vérifier cette contrainte, on peut s'y fier !</p>
<h2 id="les-dependent-types">Les dependent types</h2>
<p>Avec les phantom types, on se rend compte qu'il est possible de jouer sur le <em>type</em> plutôt que sur la <em>valeur</em> pour faire porter une information supplémentaire à notre donnée. Cependant, nous n'avons jamais mélangé <em>valeur</em> et <em>type</em> ; ceux-ci sont toujours rigoureusement séparés. </p>
<p>Imaginons qu'on possède un tableau de 5 éléments, et qu'on cherche à récupérer le 5ème élément. Les indices commencent à 0, on cherche donc à récupérer l'élément à l'index 4 grâce à la fonction <code>index</code> :</p>
<pre><code class="lang-idris">fifthElement = index <span class="hljs-number">4</span> my5Elements
</code></pre>
<p>Jusqu'ici tout va bien, et on récupère effectivement notre 5ème élément. Mais que se passerait-il si on essayait de récupérer le 6ème élément ?</p>
<pre><code class="lang-idris">sixthElement = index <span class="hljs-number">5</span> my5Elements
</code></pre>
<p>Dans la plupart des langages, ce code va déclencher une exception du style <code>OutOfBoundException</code>. Dans certains autres langages, la fonction <code>index</code> retourne un <code>Maybe</code> ou un <code>Either</code> pour représenter la possibilité d'erreur. En <a href="https://www.idris-lang.org/">Idris</a>, en revanche, ce dernier bout de code <strong>ne compile pas</strong> !</p>
<p>Comment est-ce possible ? Tout simplement parce que notre tableau d'éléments (on appelle ça un vecteur — <code>Vect</code> — en Idris) est défini comme ceci :</p>
<pre><code class="lang-idris">my5Elements : <span class="hljs-type">Vect</span> <span class="hljs-number">5</span> <span class="hljs-type">Element</span>
my5Elements = <span class="hljs-type">One</span> :: <span class="hljs-type">Two</span> :: <span class="hljs-type">Three</span> :: <span class="hljs-type">Four</span> :: <span class="hljs-type">Five</span> :: <span class="hljs-type">Nil</span>
</code></pre>
<p>Le type est très particulier : on voit un nombre – et donc une <em>valeur</em> – pour indiquer que ce <code>Vect</code> contient 5 éléments ! C'est ce qu'on appelle un <code>dependent type</code> – possible notamment en Idris – ce qui fait que le compilateur est capable de vérifier si l'index auquel on cherche à accéder est valide ou non !</p>
<p>En vérité, la fonction <code>index</code> est définie grâce au type <code>Fin n</code> qui représente les entiers naturels ou nuls strictement inférieurs à <code>n</code>. Par exemple <code>Fin 5</code> est un type qui contient les valeurs suivantes : <code>0, 1, 2, 3, 4</code>. Voici le type de <code>index</code> :</p>
<pre><code class="lang-idris">index : <span class="hljs-type">Fin</span> n -&gt; <span class="hljs-type">Vect</span> n e -&gt; e
</code></pre>
<p>On ne pourra donc jamais utiliser un nombre invalide pour accéder à l'index d'un <code>Vect</code>, et si on souhaite utiliser une valeur dynamique comme index, il faudra d'abord prouver qu'elle est dans l'interval désiré !</p>
<p>Idris est cependant principalement un langage utilisé dans la recherche et n'est pas destiné à construire des applications grand public en production. C'est pourtant le langage le plus <em>utilisable</em> comportant des <em>dependent types</em> aujourd'hui. De plus, l'étape de compilation est très lente à cause de toute la complexité supplémentaire.</p>
<p>Cela reste cependant un exemple intéressant de ce que peuvent permettre des systèmes de type.</p>
<h2 id="conclusion">Conclusion</h2>
<p>La plupart des langages les plus utilisés aujourd'hui possèdent un <em>type system</em> basique. Sans types algébriques, il est par exemple compliqué de modéliser exactement notre métier sans y incorporer de nombreux cas impossibles.  </p>
<p>On note cependant depuis peu une émergence de langages au <em>type system</em> plus avancé, comme TypeScript (même s'il est très facile de tricher dans ce langage), Swift, Kotlin et Rust. Et c'est à mon sens une très bonne chose ! </p>
<p>On voit qu'il est bien souvent possible d'inscrire dans nos types nos exigences et règles métiers. Le code s'en retrouve plus lisible et plus cohérent. Améliorer sa modélisation permet d'améliorer la compréhension qu'on a de son code et diminue du même coup la charge cognitive nécessaire pour le comprendre.</p>
<p>Chaque <code>Maybe</code> et <code>Either</code>, par exemple, peut représenter de l'incertitude. Et quand on commence à modéliser son incertitude, on réalise rapidement que nos codebases en sont remplies. C'est à ce moment précis qu'on peut alors chercher à la réduire, en utilisant au maximum nos types.</p>
</div></div></div><a class="backLink" href="/blog"><svg version="1.1" class="octicon arrowLeft" width="30" height="30" viewBox="0 0 10 16"><polygon points="6 3 0 8 6 13 6 10 10 10 10 6 6 6" fill-rule="evenodd" fill="black"></polygon></svg>Other articles</a></div></div></div></body></html>