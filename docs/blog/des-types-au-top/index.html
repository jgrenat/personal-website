<!DOCTYPE html><html lang="en"><head><link rel="preload" href="content.json" as="fetch" crossorigin=""><base href="../../"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><script>if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker.register("service-worker.js");
        });
      } else {
        console.log("No service worker registered.");
      }</script><link rel="shortcut icon" href="assets/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="assets/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="48x48" href="assets/favicon-48x48.png"><link rel="manifest" href="assets/manifest.json"><meta name="mobile-web-app-capable" content="yes"><meta name="theme-color" content="#ffffff"><meta name="application-name" content="Jordane Grenat | Personal Website"><link rel="apple-touch-icon" sizes="57x57" href="assets/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="assets/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="assets/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="assets/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="assets/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="assets/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="assets/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="assets/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="167x167" href="assets/apple-touch-icon-167x167.png"><link rel="apple-touch-icon" sizes="180x180" href="assets/apple-touch-icon-180x180.png"><link rel="apple-touch-icon" sizes="1024x1024" href="assets/apple-touch-icon-1024x1024.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="Jordane Grenat | Personal Website"><script defer="defer" src="main.js"></script><link rel="preload" href="main.js" as="script"><style>/*

Dracula Theme v1.2.0

https://github.com/zenorocha/dracula-theme

Copyright 2015, All rights reserved

Code licensed under the MIT license
http://zenorocha.mit-license.org

@author Éverton Ribeiro <nuxlli@gmail.com>
@author Zeno Rocha <hi@zenorocha.com>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #282a36;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-section,
.hljs-link {
  color: #8be9fd;
}

.hljs-function .hljs-keyword {
  color: #ff79c6;
}

.hljs,
.hljs-subst {
  color: #f8f8f2;
}

.hljs-string,
.hljs-title,
.hljs-name,
.hljs-type,
.hljs-attribute,
.hljs-symbol,
.hljs-bullet,
.hljs-addition,
.hljs-variable,
.hljs-template-tag,
.hljs-template-variable {
  color: #f1fa8c;
}

.hljs-comment,
.hljs-quote,
.hljs-deletion,
.hljs-meta {
  color: #6272a4;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-title,
.hljs-section,
.hljs-doctag,
.hljs-type,
.hljs-name,
.hljs-strong {
  font-weight: bold;
}

.hljs-emphasis {
  font-style: italic;
}
</style><style>@import url(https://fonts.googleapis.com/css?family=Rubik|Noto+Sans&display=swap);</style><style>/***** CSS Reset *******/

/* http://meyerweb.com/eric/tools/css/reset/
   v2.0 | 20110126
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed,
figure, figcaption, footer, header, hgroup,
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
}

/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure,
footer, header, hgroup, menu, nav, section {
  display: block;
}

body {
  line-height: 1;
}

ol, ul {
  list-style: none;
}

blockquote, q {
  quotes: none;
}

blockquote:before, blockquote:after,
q:before, q:after {
  content: '';
  content: none;
}

table {
  border-collapse: collapse;
  border-spacing: 0;
}

* {
  box-sizing: border-box;
}

a {
  text-decoration: none;
  color: inherit;
}

li {
  line-height: 1.9rem;
}

body {
  /* Permalink - use to edit and share this gradient: https://colorzilla.com/gradient-editor/#f5f5f5+0,ffffff+50,64b4fa+51,64b4fa+100 */
  background: #f5f5f5; /* Old browsers */
  background: -moz-linear-gradient(-45deg, #f5f5f5 0%, #ffffff 50%, #64b4fa 50%, #64b4fa 100%); /* FF3.6-15 */
  background: -webkit-linear-gradient(-45deg, #f5f5f5 0%, #ffffff 50%, #64b4fa 50%, #64b4fa 100%); /* Chrome10-25,Safari5.1-6 */
  background: linear-gradient(135deg, #f5f5f5 0%, #ffffff 50%, #64b4fa 50%, #64b4fa 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#f5f5f5', endColorstr='#64b4fa', GradientType=1); /* IE6-9 fallback on horizontal gradient */
  background-attachment: fixed;
}


/* Workaround for hljs */

pre code {
  max-width: 100%;
  font-size: 0.95rem;
  line-height: 1.4rem;
  display: block;
  overflow-x: auto;
  overflow-y: auto;
  padding: 0.5em;
  background: #282a36;
  color: #f8f8f2;
  white-space: pre-wrap;
}

figure > figcaption {
  font-size: 0.8rem;
  line-height: normal;
  font-style: italic;
  text-align: center;
}
</style><title>Des types au top</title><meta name="generator" content="elm-pages v1.3.0"><link rel="canonical" href="https://www.grenat.eu/blog/des-types-au-top"><meta name="description" content="En programmation, les types sont bien plus puissants que ce que peuvent nous laisser croire les types primitifs. Venez découvrir avec moi les super pouvoirs des types !"><meta property="og:image" content="https://www.grenat.eu/images/article-covers/types.jpg"><meta property="og:image:secure_url" content="https://www.grenat.eu/images/article-covers/types.jpg"><meta property="og:image:alt" content="En programmation, les types sont bien plus puissants que ce que peuvent nous laisser croire les types primitifs. Venez découvrir avec moi les super pouvoirs des types !"><meta property="og:title" content="Des types au top"><meta property="og:url" content="https://www.grenat.eu/blog/des-types-au-top"><meta property="og:description" content="En programmation, les types sont bien plus puissants que ce que peuvent nous laisser croire les types primitifs. Venez découvrir avec moi les super pouvoirs des types !"><meta property="og:site_name" content="Jordane Grenat | Personal Website"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:title" content="Des types au top"><meta property="twitter:description" content="En programmation, les types sont bien plus puissants que ce que peuvent nous laisser croire les types primitifs. Venez découvrir avec moi les super pouvoirs des types !"><meta property="twitter:image" content="https://www.grenat.eu/images/article-covers/types.jpg"><meta property="twitter:image:alt" content="En programmation, les types sont bien plus puissants que ce que peuvent nous laisser croire les types primitifs. Venez découvrir avec moi les super pouvoirs des types !"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-10-10"></head><body><div data-url="http://localhost:8001/blog/des-types-au-top" display="none"></div><div class="_21dae779"><style>._21dae779 {
    height:100%;
}</style><style>html {
    height:100%;
}

body {
    height:100%;
    font-size:calc(16px + 0.2vw);
    font-family:Noto Sans, sans-serif;
}

h1 {
    font-family:Rubik, serif;
    font-size:calc(1.6rem + 2vw);
    text-align:center;
    margin-bottom:5vh;
    margin-top:1vw;
}

h2 {
    font-size:calc(1.2rem + 1vw);
    text-align:center;
    margin-bottom:3vh;
    font-weight:900;
}

.opaquePanel {
    display:block;
    background-color:rgba(255, 255, 255, 0.95);
    padding:5vh 3vw;
    max-width:900px;
    width:95%;
    margin:3vh auto;
    box-shadow:0 1px 5px 1px rgba(0, 0, 0, 0.4);
}

@media only screen and (max-width: 500px) {
    .opaquePanel {
        width:100%;
    }
}</style><div class="article"><style>.article {
    margin-top:20px;
}

.article  .article-header {
    display:flex;
    flex-wrap:wrap;
    justify-content:space-between;
    align-items:center;
    margin-bottom:2vh;
}

.article  .authorCard {
    display:flex;
    align-items:center;
    flex-grow:1;
    justify-content:flex-end;
}

.article  .authorCard-name {
    text-align:right;
    font-size:1.5rem;
    margin-bottom:1vh;
}

.article  .authorCard-biography {
    text-align:right;
    font-size:1rem;
    color:rgba(0, 0, 0, 0.7);
}

.article  .authorCard-picture {
    width:5rem;
    border-radius:50%;
    margin-left:0.9vw;
}

.article  .backLink {
    display:inline-flex;
    align-items:center;
    padding:5px;
}

.article  .backLink:hover {
    background-color:#64b4fa;
}

.article  .article-title {
    margin-bottom:2vh;
}

.article  .article-publicationDate {
    display:block;
    font-size:0.95rem;
    text-align:center;
    margin-bottom:3vh;
}

.article  .article-coverPhoto {
    width:calc(100% + 6vw);
    margin:0 -3vw 3vh;
}

.article  .article-coverPhoto > img {
    width:100%;
}

.article  .article-coverPhoto-legend {
    font-size:0.9rem;
    color:rgba(0, 0, 0, 0.7);
    text-align:center;
}

.article  .article-coverPhoto-legend > a {
    text-decoration:underline;
}

.article  .article-coverPhoto-legend > a:hover {
    color:rgb(0, 0, 0);
}

.article  .markdown {
    margin-bottom:5vh;
}

.article  .markdown  h2 {
    font-size:2.5rem;
    font-weight:900;
    text-align:left;
    margin:4vh 0 2vh;
}

.article  .markdown  h3 {
    font-size:1.8rem;
    font-weight:600;
    text-align:left;
    margin:3vh 0 1vh;
    color:rgba(0, 0, 0, 0.8);
}

.article  .markdown  p {
    margin:2.5vh 0;
    line-height:1.7rem;
    white-space:pre-wrap;
    text-align:justify;
    color:rgba(0, 0, 0, 0.8);
}

.article  .markdown  p > code {
    background-color:rgba(225, 225, 255, 0.7);
    padding:1px 3px;
    font-size:0.7em;
}

.article  .markdown  blockquote {
    border-left:5px solid rgba(5, 117, 230, 0.8);
    background-color:rgba(5, 117, 230, 0.1);
    padding:0.01vh 1vw;
    margin-left:0.5vw;
    margin-right:0.5vw;
}

.article  .markdown  strong {
    font-weight:900;
    color:rgb(0, 0, 0);
}

.article  .markdown  em {
    font-style:italic;
}

.article  .markdown  a {
    text-decoration:underline;
}

.article  .markdown  a:hover {
    text-decoration:none;
}

.article  .markdown  .thanks {
    margin-top:2vw;
    font-style:italic;
    font-size:0.8em;
    text-align:right;
}

.article  .markdown  ul {
    list-style-type:disc;
    padding-left:1rem;
    margin-left:2vh;
}

.article  .markdown  ul > li + li {
    margin-top:2vh;
}</style><div class="opaquePanel"><div class="article-header"><a class="backLink" href="/blog"><svg version="1.1" class="octicon arrowLeft" width="30" height="30" viewBox="0 0 10 16"><polygon points="6 3 0 8 6 13 6 10 10 10 10 6 6 6" fill-rule="evenodd" fill="black"></polygon></svg>Other articles</a><aside class="authorCard"><div><div class="authorCard-name">Jordane Grenat</div><p class="authorCard-biography">Web developer and software craftsman</p></div><img src="images/author/jordane.jpeg" alt="Jordane Grenat" class="authorCard-picture"></aside></div><h1 class="article-title">Des types au top</h1><time class="article-publicationDate" datetime="2019-10-10">October 10th, 2019</time><figure class="article-coverPhoto"><img src="images/article-covers/types.jpg" alt="Article cover photo"></figure><div class="markdown"><div><div><h2 id="le-commencement">Le commencement</h2>
<p>Ayant débuté avec PHP et JavaScript, j'ai longtemps cru que les types se limitaient en programmation à ce que j'en voyais alors : une donnée peut être un <code>number</code>, une <code>string</code>, un <code>bool</code>, une <code>list</code> ou  un <code>object</code>. Toute donnée dans mes programmes était une composition de ces différents éléments.</p>
<p>Par exemple, la représentation d'un dix de coeur dans un jeu de cartes pouvait être :</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> tenOfHeart = { <span class="hljs-attr">value</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">color</span>: <span class="hljs-string">'hearts'</span> };
</code></pre>
<p>Mais alors comment représenter un valet de coeur ? Tout simplement en considérant qu'un valet vaut <code>11</code> !</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> jackOfHeart = { <span class="hljs-attr">value</span>: <span class="hljs-number">11</span>, <span class="hljs-attr">color</span>: <span class="hljs-string">'hearts'</span> };
</code></pre>
<p>Cela ne me choquait pas à l'époque. En regardant ce type de code aujourd'hui, deux considérations me viennent immédiatement à l'esprit. La première est que ce modèle va nous obliger à avoir une traduction mentale de nos valeurs : partout où on veut représenter un valet, on doit se souvenir qu'il correspond au <code>11</code>,  puis la dame au <code>12</code>, etc. C'est un effort cognitif à produire en plus et une chance de plus de commettre une erreur. Donc un bug !</p>
<p>L'autre considération est plus préoccupante : si la dame vaut <code>12</code>, le roi <code>13</code> et l'as <code>1</code>, que valent ces cartes ?</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> wtfOfHeart = { <span class="hljs-attr">value</span>: <span class="hljs-number">199</span>, <span class="hljs-attr">color</span>: <span class="hljs-string">'hearts'</span> };
<span class="hljs-keyword">const</span> what = { <span class="hljs-attr">value</span>: <span class="hljs-number">2.6</span>, <span class="hljs-attr">color</span>: <span class="hljs-string">'hearts'</span> };
<span class="hljs-keyword">const</span> areYouKidding = { <span class="hljs-attr">value</span>: <span class="hljs-literal">NaN</span>, <span class="hljs-attr">color</span>: <span class="hljs-string">'green'</span> };
</code></pre>
<p>Et c'est là l'un des principaux problèmes des types basiques : mis à part le type <code>bool</code> qui peut avoir deux valeurs (<code>true</code> et <code>false</code>), tous les autres types peuvent avoir virtuellement une infinité de valeurs possibles ! Or, il n'existe que 52 cartes dans le jeu classique qu'on souhaite représenter ! </p>
<p>Notre représentation d'une carte peut donc avoir une infinité de valeurs possibles alors qu'on souhaite en gérer 52 au maximum. Il s'ensuit qu'il existe une <code>infinité - 52 = toujours une infinité</code> de valeurs absurdes qui peuvent perturber l'exécution de notre programme ! Ce qui va nous obliger aux emplacements stratégiques à effectuer des vérifications :</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> validColors = [<span class="hljs-string">'hearts'</span>, <span class="hljs-string">'spades'</span>, <span class="hljs-string">'clubs'</span>, <span class="hljs-string">'diamonds'</span>];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">playCard</span>(<span class="hljs-params">card</span>) </span>{
    <span class="hljs-keyword">if</span> (card.value &lt; <span class="hljs-number">1</span> || card.value &gt; <span class="hljs-number">13</span> 
        || !validColors.includes(card.colors)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Invalid card!'</span>)
    }
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<h2 id="java-la-rescousse">Java à la rescousse</h2>
<p>J'ai plus tard appris Java, découvrant au passage les <code>enum</code>s. C'est une façon bien pratique de représenter un nombre fini de valeurs, ce qui nous donne au final :</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Value {
    ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, 
    EIGHT, NINE, TEN, JACK, QUEEN, KING;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Color {
    HEARTS, CLUBS, SPADES, DIAMONDS;
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Card</span> </span>{
    <span class="hljs-keyword">public</span> Value value;
    <span class="hljs-keyword">public</span> Color color;
}
</code></pre>
<p>Les choses s'améliorent ! Si on regarde le type <code>Value</code>, on se rend compte qu'il contient seulement 13 valeurs possibles et le type <code>Color</code> peut prendre 4 valeurs différentes. Le type <code>Card</code> étant composé d'une <code>Value</code> et d'une <code>Color</code>, on peut donc représenter la combinaison des deux, c'est-à-dire <code>13 * 4 = 52</code> valeurs différentes. Voyez comme les possibilités des types se <em>multiplient</em> quand on les combine !</p>
<p>Et ça tombe bien, notre jeu contient 52 cartes différentes, on peut donc uniquement modéliser des cartes valides ! Cela signifie qu'il n'est pas nécessaire de vérifier par la suite que notre carte est valide, comme c'était le cas avant. On gagne en sécurité dans notre code en ne permettant pas de représenter des états non cohérents, que nous appellerons <strong>états impossibles</strong>.</p>
<p>On gagne aussi en clarté en lisant le code : plus besoin de faire un effort mental pour convertir <code>11</code> en <code>Jack</code>, puisque dans le code nous utilisons directement <code>JACK</code>.</p>
<h2 id="le-joker-pas-celui-de-joaquin-phoenix-">Le joker (pas celui de Joaquin Phoenix)</h2>
<p>Tout va bien jusqu'à ce qu'on se rappelle un petit élément d'importance : notre jeu de 52 cartes en contient en vérité 54, puisqu'il y a les deux jokers (le rouge et le noir). Et comme je veux jouer au <a href="https://www.maison-facile.com/magazine/multimedia/se-divertir/jouer-entre-amis/188-jeux-de-cartes-le-8-americain/">8 américain</a>, j'en ai besoin ! Modifions donc notre modèle :</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Value {
    ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, 
    EIGHT, NINE, TEN, JACK, QUEEN, KING, JOKER;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Color {
    HEARTS, CLUBS, SPADES, DIAMONDS, RED, BLACK;
}
</code></pre>
<p>Avez-vous remarqué ce qu'il vient de se passer ? Notre type <code>Value</code> contient maintenant <code>14</code> valeurs possibles, et le type <code>Color</code> en contient 6. Si on les combine, on se rend compte que notre type <code>Card</code> peut représenter <code>14 * 6 = 84</code> valeurs ! On a donc 30 valeurs impossibles qui se sont glissés avec nos <code>52 + 2 = 54</code> valeurs possibles. Encore une fois, il faudra faire des vérifications dans le code...</p>
<p>Ou peut-être que non ?</p>
<h2 id="les-types-alg-briques">Les types algébriques</h2>
<p>Rappelez-vous : combiner deux valeurs dans un objet revient à multiplier les cas possibles de chacune de ces valeurs :</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Card</span> </span>{
    <span class="hljs-keyword">public</span> Value value;
    <span class="hljs-keyword">public</span> Color color;
}
<span class="hljs-comment">// Value * Color = 13 * 4 = 52</span>
</code></pre>
<p>Le nombre de valeurs possibles d'un type s'appelle la <strong>cardinalité</strong>. Ici, la cardinalité du type <code>Value</code> est 13 (= il peut avoir 13 valeurs différentes), celle du type <code>Color</code> est 4 et celle du type <code>Card</code> est 52.</p>
<p>Pour obtenir 54 valeurs possibles et représenter nos deux jokers, on aimerait idéalement pouvoir avoir une cardinalité de <code>52 + 2 = 54</code>. Or, nous savons uniquement <em>multipler</em> les cardinalités des types, pas les additionner ! Vraiment ? Ce n'est pas si sûr !</p>
<p>Si on ajoutait simplement une nouvelle couleur, notre type <code>Color</code> deviendrait ainsi :</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Color {
    HEARTS, CLUBS, SPADES, DIAMONDS, NEW_COLOR;
}
</code></pre>
<p>Sa cardinalité devient donc <code>4 + 1 = 5</code>. Eh oui, ajouter 1 membre à un enum équivaut à ajouter 1 à sa cardinalité !</p>
<p>Prenons maintenant un peu de recul. Pour décrire le type <code>Color</code> en toutes lettres, on pourrait dire ceci :</p>
<blockquote>
<p><code>Color</code> est un type qui peut valoir <code>HEARTS</code> <strong>ou</strong> <code>CLUBS</code> <strong>ou</strong> <code>SPADES</code> <strong>ou</strong> <code>DIAMONDS</code> <strong>ou</strong> <code>NEW_COLOR</code>.</p>
</blockquote>
<p>A l'inverse, on constate que notre type <code>Card</code> serait plutôt décrit de la façon suivante :</p>
<blockquote>
<p><code>Card</code> est un type composé d'une <code>Value</code> <strong>et</strong> d'une <code>Color</code>. </p>
</blockquote>
<p>Intuitivement, on comprend donc qu'un "<strong>ou</strong>" revient à <em>additionner</em> les cardinalités, alors qu'un "<strong>et</strong>" revient à <em>multipler</em> les cardinalités !</p>
<p>Mais alors comment décrire  notre type <code>Card</code> contenant les deux jokers ? Voilà ce que je propose :</p>
<blockquote>
<p>Card est un type qui peut valoir <code>BLACK_JOKER</code> <strong>ou</strong> <code>RED_JOKER</code> <strong>ou</strong> être composé d'une <code>Value</code> <strong>et</strong> d'une <code>Color</code>.</p>
</blockquote>
<p> On voit donc qu'on souhaite <em>additionner</em> trois éléments différents, dont le dernier est une <em>multiplication</em> de deux éléments. Quelque chose comme ça :</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Card {
    BLACK_JOKER, RED_JOKER, SIMPLE_CARD(Value, Color);
}
</code></pre>
<p>Sauf qu'évidemment, cette syntaxe n'est pas du Java valide ! Il s'agit d'un <strong>type algébrique</strong>, c'est-à-dire un type composé d'autres types, soit en les additionnant (on parle alors de <code>types somme</code>), soit en les multipliant (on parle alors de <code>types produit</code>). </p>
<p>Ils ne sont malheureusement pas supportés dans tous les langages. Voilà comment on pourrait le représenter en <a href="./ce-que-jaime-en-elm">Elm, un langage front-end compilant en JavaScript</a> :</p>
<pre><code class="lang-elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Card</span> =
    <span class="hljs-type">BlackJoker</span> 
    | <span class="hljs-type">RedJoker</span>
    | <span class="hljs-type">SimpleCard</span> <span class="hljs-type">Value</span> <span class="hljs-type">Color</span>
</code></pre>
<p>On peut ensuite utiliser ce type :</p>
<pre><code class="lang-elm"><span class="hljs-title">myBlackJoker</span> = <span class="hljs-type">BlackJoker</span>
<span class="hljs-title">myTenOfClubs</span> = <span class="hljs-type">SimpleCard</span> <span class="hljs-type">Ten</span> <span class="hljs-type">Clubs</span>
</code></pre>
<p>Il n'est ainsi plus possible de représenter de valeurs impossibles dans notre programme ! La cardinalité de notre représentation est égale à la cardinalité du problème métier qu'on souhaite représenter. On peut donc éviter partout dans le code des vérifications manuelles : si on possède une valeur de type <code>Card</code>, celle-ci est forcément valide. C'est toute une catégorie de bugs évitée !</p>
<p>Les langages supportant les <em>types algébriques</em> sont par exemple Rust, Haskell, Scala, OCaml, Elm, ReasonML, etc. Ce sont surtout des langages fonctionnels. Certains les utilisent plus ou moins en <a href="https://proandroiddev.com/algebraic-data-types-in-kotlin-337f22ef230a"><em>Kotlin</em></a> également.</p>
<h2 id="j-ai-menti-">J'ai menti...</h2>
<p>Il faut que je fasse un aveu : je vous ai menti dans les premières parties de cet article. Plus exactement en parlant du code suivant :</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Value {
    ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, 
    EIGHT, NINE, TEN, JACK, QUEEN, KING;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Color {
    HEARTS, CLUBS, SPADES, DIAMONDS;
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Card</span> </span>{
    <span class="hljs-keyword">public</span> Value value;
    <span class="hljs-keyword">public</span> Color color;
}
</code></pre>
<p>Je vous ai affirmé que la cardinalité du type <code>Card</code> était de <code>13 * 4 = 52</code>, mais ce n'est pas le cas. En effet, nous sommes en Java et il faut donc compter avec la possibilité que les valeurs soient <code>null</code>. On a donc 5 valeurs possibles pour la <code>Color</code> (<code>HEARTS</code>, <code>CLUBS</code>, <code>SPADES</code>, <code>DIAMONDS</code> et <code>null</code>) et 14 valeurs possibles pour la <code>Value</code>, ce qui nous fait une cardinalité de <code>14 * 5 = 70</code>, bien au-delà de la cardinalité qu'on cherchait à représenter !</p>
<p><code>null</code> est censé représenter une valeur qui n'est pas présente, souvent parce qu'elle n'a pas été initialisée. Mais cette valeur est un peu magique : <code>null</code> peut être de n'importe quel type et on doit donc le compter dans toutes nos cardinalités. </p>
<p>Beaucoup d'exceptions et de bugs sont dus à ces valeurs <code>null</code> en Java, parce que le développeur oublie de les gérer. En JavaScript, c'est même pire, puisqu'on a <code>null</code> et <code>undefined</code> à prendre en compte ! A tel point que des langages ont décidé de ne pas avoir cette <em>valeur joker</em> dans le langage. </p>
<p>Mais alors comment représenter une valeur qui peut être définie ou non ? Essayons en toutes lettres de définir une chaine de caractères qui peut ne pas être définie :</p>
<blockquote>
<p>C'est une valeur qui peut valoir <code>null</code> <strong>ou</strong> contenir une <code>String</code></p>
</blockquote>
<p>Est-ce que ça ne ressemble pas à un <em>type somme</em> ? Et effectivement, c'est comme ça que ces langages le définissent, petit exemple en Elm :</p>
<pre><code class="lang-elm"><span class="hljs-keyword">type</span> <span class="hljs-type">MaybeString</span> = 
    <span class="hljs-type">Nothing</span>
    | <span class="hljs-type">Just</span> <span class="hljs-type">String</span>
</code></pre>
<p>On voit que la valeur est soit <code>Nothing</code>, soit un <code>Just</code> contenant notre chaine de caractères. Et ça fait toute la différence avec le <code>null</code> de Java : partout où une valeur peut ne pas être définie, le développeur doit l'indiquer dans son type (en utilisant <code>MaybeString</code> au lieu de <code>String</code> par exemple). Comme c'est <em>explicite</em>, le compilateur peut donc vous forcer à gérer le cas, évitant un bug dû à l'inattention d'un développeur !</p>
<p>J'ai également menti une seconde fois : le type <code>MaybeString</code> n'existe pas en Elm. Il s'agit en fait d'un type <code>Maybe</code> générique qui prend en argument un type (<code>a</code> dans l'exemple ci-dessous) pour retourner un <code>Maybe a</code>. Cela évite de redéfinir un <code>MaybeInt</code>, un <code>MaybeString</code>, un <code>MaybeCard</code>... Voyez le <code>a</code> comme une variable représentant un type.</p>
<pre><code class="lang-elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Maybe</span> a =
    <span class="hljs-type">Nothing</span>
    | <span class="hljs-type">Just</span> a

<span class="hljs-title">myCard</span> : <span class="hljs-type">Maybe</span> <span class="hljs-type">Card</span> <span class="hljs-comment">-- indique le type de myCard</span>
<span class="hljs-title">myCard</span> = <span class="hljs-type">Just</span> <span class="hljs-type">RedJoker</span>
</code></pre>
<p>C'est fini, plus de mensonges entre nous !</p>
<h2 id="des-applications-d-exception">Des applications d'exception</h2>
<p>La grande force des types algébriques, c'est qu'ils vous donnent les moyens de modéliser votre modèle de façon beaucoup plus précise ! Nous l'avons vu pour le cas des valeurs qui peuvent être non définies, mais les applications sont très nombreuses.</p>
<p>Par exemple, prenons une opération qui peut échouer : nous essayons de lire le contenu d'un fichier. Cette requête peut échouer de différentes manières : le fichier n'existe pas, le programme n'a pas les droits en lecture, le fichier est bloqué par une autre ressource, .... Dans certains langages, la façon de gérer ces erreurs est toute trouvée : les <em>exceptions</em>. En Java notamment, il faut <em>penser</em> à gérer ces exceptions avec un bloc <code>try...catch</code> :</p>
<pre><code class="lang-java"><span class="hljs-keyword">try</span> {
    Files.readAllLines(filePath, UTF_8);`
} <span class="hljs-keyword">catch</span> (IOException e) {
    <span class="hljs-comment">// gestion de l'erreur</span>
}
</code></pre>
<p>C'est ici acceptable parce que le compilateur force l'utilisateur à gérer cette <code>IOException</code> explicitement, soit avec ce bloc <code>try...catch</code>, soit en indiquant dans la définition de la fonction que celle-ci peut renvoyer une exception. Cependant, en lisant <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines(java.nio.file.Path,%20java.nio.charset.Charset%29">la documentation de <code>Files.readAllLines</code></a>, on se rend compte qu'il existe un second type d'exception, <code>SecurityException</code> qui est une <code>RuntimeException</code>. </p>
<p>Pour ceux qui ne font pas de Java, cela veut dire que le développeur n'est pas <em>obligé</em> de gérer cette erreur. Et j'irai même plus loin : rien n'est fait pour que le développeur ait <em>conscience</em> que cette erreur peut se produire ! Il est dès lors possible que ces erreurs se manifestent en production.</p>
<p>Une exception va remonter la pile d'appels jusqu'à ce qu'elle soit attrapée par un <code>try...catch</code> ou remonter jusqu'à l'utilisateur le cas échéant. Dans de plus en plus de langages, on a tendance à ne plus utiliser d'exceptions à cause de ce côté <em>magique</em> et implicite. Pour rendre cela explicite, on fait porter cette information par le type de retour de notre fonction, comme on pouvait le faire plus haut avec un <code>Maybe String</code> pour une valeur pouvant être non définie.</p>
<p>En Rust par exemple, il existe un type <code>Result</code>  défini comme ceci :</p>
<pre><code class="lang-rust"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Result</span></span>&lt;T, E&gt; {
   <span class="hljs-literal">Ok</span>(T),
   <span class="hljs-literal">Err</span>(E),
}
</code></pre>
<p><code>T</code> et <code>E</code> sont des variables de types, cela signifie donc que notre valeur de type <code>Result</code> est soit un <code>Ok</code> contenant une valeur de type <code>T</code>, soit un <code>Err</code> de  type <code>E</code>. Dès lors, le développeur est obligé d'extraire cette valeur et donc de considérer et gérer le cas d'erreur de façon explicite.</p>
<p>La signature de la fonction <code>read</code> en Rust est du coup la suivante :</p>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">usize</span>, io::Error&gt;
</code></pre>
<p>La seule partie importante pour nous est le retour : on reçoit un <code>Result</code> qui, en cas de succès va être un <code>Ok</code> contenant un <code>usize</code> (un pointeur en mémoire vers le résultat) et en cas d'échec va être un <code>Err</code> contenant la cause de l'erreur de type <code>io::Error</code>.</p>
<p>On voit ici qu'en plus de sécuriser le développement de l'application en forçant le développeur à gérer les cas d'erreur, le type <code>Result</code> joue le rôle de <strong>documentation</strong> du code : on <em>sait</em> que cette méthode peut échouer en lisant la signature.</p>
<h2 id="je-perds-la-bool-">Je perds la <em>bool</em></h2>
<p>Mais pas besoin d'avoir des <em>types algébriques</em> pour améliorer son code grâce aux types, on peut déjà aller loin avec des <em>enum</em>s. Regardons cette fonction en Java, permettant de commander un produit en ligne :</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> Order <span class="hljs-title">orderProduct</span><span class="hljs-params">(Product product, <span class="hljs-keyword">boolean</span> withGiftWrap)</span> </span>{
    <span class="hljs-comment">// ...</span>
}

orderProduct(book, <span class="hljs-keyword">true</span>);
</code></pre>
<p>On peut remarquer deux choses : la fonction retourne un <code>Order</code>, alors que d'expérience, ce genre de méthode peut sûrement échouer pour de nombreuses raisons différentes. Cela signifie que cette méthode a de grandes chances de lancer des exceptions en cas d'erreur ! Mais passons, c'est le second point qui nous intéresse ici : si on ne voit que l'appel de la fonction, on peut se demander ce que signifie ce <code>true</code> passé en second argument.  La seule façon de le savoir est d'aller voir la définition de la fonction pour constater qu'il s'agit de l'ajout ou non de papier cadeau. On appelle cela <em>boolean blindness</em>.</p>
<p>Souvent, les booléens sont utilisés par facilité, alors que l'utilisation d'un enum améliorerait de beaucoup la lisibilité :</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> GiftWrap {
    NO_GIFT_WRAP, WITH_GIFT_WRAP;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> Order <span class="hljs-title">orderProduct</span><span class="hljs-params">(Product product, GiftWrap giftWrap)</span> </span>{
    <span class="hljs-comment">// ...</span>
}

orderProduct(book, WITH_GIFT_WRAP);
</code></pre>
<p>N'est-ce pas plus lisible ? Et surtout cela nous permettra d'évoluer plus facilement : si demain on souhaite laisser le choix entre deux types de papier cadeaux, on peut juste rajouter des éléments à l'enum :</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> GiftWrap {
    NO_GIFT_WRAP, CHILD_GIFT_WRAP, ADULT_GIFT_WRAP;
}
</code></pre>
<p>A chaque fois qu'on se retrouve à utiliser des booléens, il faut se demander si notre intention ne serait pas plus clair avec un enum explicitant vraiment la valeur métier.</p>
<h2 id="l-appliquer-d-s-aujourd-hui">L'appliquer dès aujourd'hui</h2>
<p>Si vous avez l'occasion d'utiliser un langage avec des types algébriques qui correspond à votre problème, foncez ! Ce n'est cependant pas toujours le cas, et bien qu'il soit possible d'émuler leur fonctionnement dans certains langages, la création est souvent peu pratique.</p>
<p>Cependant, on trouve dans tous les langages des bibliothèques d'utilitaires fournissant des éléments comme le <code>Maybe</code> (parfois appelé <code>Option</code> ou <code>Optional</code>) et le <code>Result</code> (parfois appelé <code>Either</code>,  <code>Try</code> s'il est  spécialisé pour des exceptions). C'est le cas en Java notamment avec <a href="https://www.vavr.io/">l'excellente bibliothèque Vavr</a>. En TypeScript, vous pouvez également activer l'option <a href="https://basarat.gitbooks.io/typescript/docs/options/strictNullChecks.html"><code>strictNullChecks</code></a> qui ajoute plus de vérifications sur les <code>null</code> et <code>undefined</code>.</p>
<p>Dans tous les cas, mon premier conseil est le suivant : débarrassez-vous de <code>null</code>. Rendez  l'absence de valeur explicite et vous éviterez beaucoup de problèmes. Faites de même avec les exceptions.</p>
<p>Mon second conseil est d'éviter au maximum la <em>primitive obsession</em> : n'hésitez pas à créer des objets / enums plutôt que d'utiliser les types primitifs comme <code>string</code>, <code>bool</code> et <code>number</code>. Il me semble avoir vu un jour cette citation dont je ne connais ni l'origine ni l'auteur et que j'ai peut-être involontairement déformée (n'hésitez pas à m'envoyer la référence si vous l'avez) :</p>
<blockquote>
<p>Quand vous écrivez qu'une fonction prend un <code>string</code> en argument, votre fonction <em>doit</em> accepter l'intégralité des oeuvres de Shakespeare en mandarin en paramètre.</p>
</blockquote>
<p>Et mon dernier conseil est sans doute le plus important : essayez de rendre possible uniquement les valeurs que votre métier accepte ; éliminez grâce aux types le maximum d'états impossibles. En ce sens, je vous recommande cet excellent talk de Richard Feldman (en anglais) : <a href="https://www.youtube.com/watch?v=IcgmSRJHu_8">Making impossible states impossible</a>.</p>
<p><strong><a href="/blog/des-types-au-top-2">Cet article possède une seconde partie, cliquez ici pour lire la suite.</a></strong></p>
</div></div></div><a class="backLink" href="/blog"><svg version="1.1" class="octicon arrowLeft" width="30" height="30" viewBox="0 0 10 16"><polygon points="6 3 0 8 6 13 6 10 10 10 10 6 6 6" fill-rule="evenodd" fill="black"></polygon></svg>Other articles</a></div></div></div></body></html>