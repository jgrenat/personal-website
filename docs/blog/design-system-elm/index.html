<!DOCTYPE html><html lang="en"><head><link rel="preload" href="content.json" as="fetch" crossorigin=""><base href="../../"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><script>if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker.register("service-worker.js");
        });
      } else {
        console.log("No service worker registered.");
      }</script><link rel="shortcut icon" href="assets/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="assets/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="assets/favicon-32x32.png"><link rel="icon" type="image/png" sizes="48x48" href="assets/favicon-48x48.png"><link rel="manifest" href="assets/manifest.json"><meta name="mobile-web-app-capable" content="yes"><meta name="theme-color" content="#ffffff"><meta name="application-name" content="Jordane Grenat | Personal Website"><link rel="apple-touch-icon" sizes="57x57" href="assets/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="assets/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="assets/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="assets/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="assets/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="assets/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="assets/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="assets/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="167x167" href="assets/apple-touch-icon-167x167.png"><link rel="apple-touch-icon" sizes="180x180" href="assets/apple-touch-icon-180x180.png"><link rel="apple-touch-icon" sizes="1024x1024" href="assets/apple-touch-icon-1024x1024.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="Jordane Grenat | Personal Website"><script defer="defer" src="main.js"></script><link rel="preload" href="main.js" as="script"><style>/*

Dracula Theme v1.2.0

https://github.com/zenorocha/dracula-theme

Copyright 2015, All rights reserved

Code licensed under the MIT license
http://zenorocha.mit-license.org

@author Éverton Ribeiro <nuxlli@gmail.com>
@author Zeno Rocha <hi@zenorocha.com>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #282a36;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-section,
.hljs-link {
  color: #8be9fd;
}

.hljs-function .hljs-keyword {
  color: #ff79c6;
}

.hljs,
.hljs-subst {
  color: #f8f8f2;
}

.hljs-string,
.hljs-title,
.hljs-name,
.hljs-type,
.hljs-attribute,
.hljs-symbol,
.hljs-bullet,
.hljs-addition,
.hljs-variable,
.hljs-template-tag,
.hljs-template-variable {
  color: #f1fa8c;
}

.hljs-comment,
.hljs-quote,
.hljs-deletion,
.hljs-meta {
  color: #6272a4;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-title,
.hljs-section,
.hljs-doctag,
.hljs-type,
.hljs-name,
.hljs-strong {
  font-weight: bold;
}

.hljs-emphasis {
  font-style: italic;
}
</style><style>@import url(https://fonts.googleapis.com/css?family=Rubik|Noto+Sans&display=swap);</style><style>/***** CSS Reset *******/

/* http://meyerweb.com/eric/tools/css/reset/
   v2.0 | 20110126
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed,
figure, figcaption, footer, header, hgroup,
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
}

/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure,
footer, header, hgroup, menu, nav, section {
  display: block;
}

body {
  line-height: 1;
}

ol, ul {
  list-style: none;
}

blockquote, q {
  quotes: none;
}

blockquote:before, blockquote:after,
q:before, q:after {
  content: '';
  content: none;
}

table {
  border-collapse: collapse;
  border-spacing: 0;
}

* {
  box-sizing: border-box;
}

a {
  text-decoration: none;
  color: inherit;
}


pre code {
  max-width: 100%;
  overflow-y: auto;
  line-height: 1.2rem;
  font-size: 0.95rem;
  display: inline-block;
}

li {
  line-height: 1.9rem;
}

body {
  /* Permalink - use to edit and share this gradient: https://colorzilla.com/gradient-editor/#f5f5f5+0,ffffff+50,64b4fa+51,64b4fa+100 */
  background: #f5f5f5; /* Old browsers */
  background: -moz-linear-gradient(-45deg, #f5f5f5 0%, #ffffff 50%, #64b4fa 50%, #64b4fa 100%); /* FF3.6-15 */
  background: -webkit-linear-gradient(-45deg, #f5f5f5 0%, #ffffff 50%, #64b4fa 50%, #64b4fa 100%); /* Chrome10-25,Safari5.1-6 */
  background: linear-gradient(135deg, #f5f5f5 0%, #ffffff 50%, #64b4fa 50%, #64b4fa 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#f5f5f5', endColorstr='#64b4fa', GradientType=1); /* IE6-9 fallback on horizontal gradient */
  background-attachment: fixed;
}


/* Workaround for hljs */

pre code {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #282a36;
  color: #f8f8f2;
  white-space: pre-wrap;
}

figure > figcaption {
  font-size: 0.8rem;
  line-height: normal;
  font-style: italic;
  text-align: center;
}
</style><title>Un design system en Elm</title><meta name="generator" content="elm-pages v1.3.0"><link rel="canonical" href="https://www.grenat.eu/blog/design-system-elm"><meta name="description" content="La méthodologie du design system apporte beaucoup au développement front-end. Sans surprise, Elm s'est révélé particulièrement adapté à l'implémentation de cette méthodologie !"><meta property="og:image" content="https://www.grenat.eu/images/article-covers/legos.png"><meta property="og:image:secure_url" content="https://www.grenat.eu/images/article-covers/legos.png"><meta property="og:image:alt" content="La méthodologie du design system apporte beaucoup au développement front-end. Sans surprise, Elm s'est révélé particulièrement adapté à l'implémentation de cette méthodologie !"><meta property="og:title" content="Un design system en Elm"><meta property="og:url" content="https://www.grenat.eu/blog/design-system-elm"><meta property="og:description" content="La méthodologie du design system apporte beaucoup au développement front-end. Sans surprise, Elm s'est révélé particulièrement adapté à l'implémentation de cette méthodologie !"><meta property="og:site_name" content="Jordane Grenat | Personal Website"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:title" content="Un design system en Elm"><meta property="twitter:description" content="La méthodologie du design system apporte beaucoup au développement front-end. Sans surprise, Elm s'est révélé particulièrement adapté à l'implémentation de cette méthodologie !"><meta property="twitter:image" content="https://www.grenat.eu/images/article-covers/legos.png"><meta property="twitter:image:alt" content="La méthodologie du design system apporte beaucoup au développement front-end. Sans surprise, Elm s'est révélé particulièrement adapté à l'implémentation de cette méthodologie !"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-12-10"></head><body><div data-url="http://localhost:8000/blog/design-system-elm" display="none"></div><div class="_21dae779"><style>._21dae779 {
    height:100%;
}</style><style>html {
    height:100%;
}

body {
    height:100%;
    font-size:calc(16px + 0.3vw);
    font-family:Noto Sans, sans-serif;
}

h1 {
    font-family:Rubik, serif;
    font-size:calc(1.6rem + 2vw);
    text-align:center;
    margin-bottom:5vh;
    margin-top:1vw;
}

h2 {
    font-size:calc(1.2rem + 1vw);
    text-align:center;
    margin-bottom:3vh;
    font-weight:900;
}

.opaquePanel {
    display:block;
    background-color:rgba(255, 255, 255, 0.95);
    padding:5vh 3vw;
    max-width:900px;
    width:95%;
    margin:3vh auto;
    box-shadow:0 1px 5px 1px rgba(0, 0, 0, 0.4);
}

@media only screen and (max-width: 500px) {
    .opaquePanel {
        width:100%;
    }
}</style><div class="article"><style>.article {
    margin-top:20px;
}

.article  .article-header {
    display:flex;
    flex-wrap:wrap;
    justify-content:space-between;
    align-items:center;
    margin-bottom:2vh;
}

.article  .authorCard {
    display:flex;
    align-items:center;
    flex-grow:1;
    justify-content:flex-end;
}

.article  .authorCard-name {
    text-align:right;
    font-size:1.5rem;
    margin-bottom:1vh;
}

.article  .authorCard-biography {
    text-align:right;
    font-size:1rem;
    color:rgba(0, 0, 0, 0.7);
}

.article  .authorCard-picture {
    width:5rem;
    border-radius:50%;
    margin-left:0.9vw;
}

.article  .backLink {
    display:inline-flex;
    align-items:center;
    padding:5px;
}

.article  .backLink:hover {
    background-color:#64b4fa;
}

.article  .article-title {
    margin-bottom:2vh;
}

.article  .article-publicationDate {
    display:block;
    font-size:0.95rem;
    color:rgba(0, 0, 0, 0.8);
    text-align:center;
    margin-bottom:3vh;
}

.article  .article-coverPhoto {
    width:calc(100% + 6vw);
    margin:0 -3vw 2vh;
}

.article  .markdown {
    margin-bottom:5vh;
}

.article  .markdown  h2 {
    font-size:2.5rem;
    font-weight:900;
    text-align:left;
    margin:4vh 0 2vh;
}

.article  .markdown  h3 {
    font-size:1.8rem;
    font-weight:600;
    text-align:left;
    margin:3vh 0 1vh;
    color:rgba(0, 0, 0, 0.8);
}

.article  .markdown  p {
    margin:2.5vh 0;
    line-height:1.7rem;
    white-space:pre-wrap;
}

.article  .markdown  p > code {
    background-color:rgba(225, 225, 255, 0.7);
    padding:1px 3px;
    font-size:0.7em;
}

.article  .markdown  blockquote {
    border-left:5px solid rgba(5, 117, 230, 0.8);
    background-color:rgba(5, 117, 230, 0.1);
    padding:0.01vh 1vw;
    margin-left:0.5vw;
    margin-right:0.5vw;
}

.article  .markdown  ul {
    list-style-type:disc;
    padding-left:1rem;
    margin-left:2vh;
}

.article  .markdown  ul > li + li {
    margin-top:2vh;
}</style><div class="opaquePanel"><div class="article-header"><a class="backLink" href="/blog"><svg version="1.1" class="octicon arrowLeft" width="30" height="30" viewBox="0 0 10 16"><polygon points="6 3 0 8 6 13 6 10 10 10 10 6 6 6" fill-rule="evenodd" fill="black"></polygon></svg>Other articles</a><aside class="authorCard"><div><div class="authorCard-name">Jordane Grenat</div><p class="authorCard-biography">Web developer and software craftsman</p></div><img src="images/author/jordane.jpeg" alt="Jordane Grenat" class="authorCard-picture"></aside></div><h1 class="article-title">Un design system en Elm</h1><time class="article-publicationDate" datetime="2019-12-10">December 10th, 2019</time><img src="images/article-covers/legos.png" alt="Article cover photo" class="article-coverPhoto"><div class="markdown"><div><div><p>Dans ma boîte, nous avons récemment démarré notre premier projet Elm pour un client. Je ne l'avais jusqu'à présent utilisé que pour des projets personnels ou des projets internes. Collaborant avec un graphiste et fort de mes expériences précédentes dans le monde JavaScript, j'ai tout de suite opté pour la méthodologie du Design System. </p>
<p>L'idée est simple : plutôt que de travailler sur des pages entières, on va travailler sur les différents composants de nos pages. Ces composants sont développés indépendamment les uns des autres avec une collaboration forte entre un designer et un développeur. Le design system centralise ensuite toutes les règles et propriétés du projet (couleurs, espacements, typographies, etc.) ainsi que les composants sous leurs différents états.</p>
<p>Cet article n'étant pas destiné à rentrer dans les détails de la méthodologie en elle-même, je vous redirige vers cet excellent talk où Cécile Freyd-Foucault et Florent Berthelot l'expliquent point par point : <a href="https://www.youtube.com/watch?v=jXcO7Qu1Gjs">Designers, développeurs, créons la différence !</a></p>
<p>Ce qu'il faut retenir pour la suite de cet article, c'est qu'on essaye de centraliser au maximum les règles et composants graphiques de notre site pour l'exposer dans un endroit facilement accessible.</p>
<h2 id="design-system-en-elm">Design system en Elm</h2>
<p>J'étais assez curieux de voir ce que donnerait cette     approche en Elm. L'idée d'avoir un langage fonctionnel dans lequel tout est pur et centré autour de fonctions réutilisables me semblait parfaitement correspondre. Et comme je le pensais, Elm s'est révélé idéal pour implémenter un design system !</p>
<blockquote>
<p>Avant d'aller plus loin, il me faut cependant éclaircir un point. Je vais parler dans la suite de cet article de <strong>composants</strong>. Ce terme désigne un élément visuellement distinct dans une page web, comme par exemple une carte dans une liste,  un tableau dans une page, etc. Dans le monde JavaScript, ce terme a tendance à signifier quelque chose de similaire, mais avec une particularité supplémentaire : les composants gèrent en général un état interne invisible de l'extérieur. En Elm, on cherchera à éviter au maximum les composants ayant un état interne pour privilégier au maximum les fonctions pures.</p>
</blockquote>
<p>Nous avions plusieurs choix techniques possibles pour créer nos règles et composants :</p>
<ul>
<li>utiliser la bibliothèque standard <code>elm/html</code> avec un fichier CSS et des classes suivant <a href="https://www.alsacreations.com/article/lire/1641-bonnes-pratiques-en-css-bem-et-oocss.html">les méthodologies OOCSS ou BEM</a></li>
<li>utiliser <a href="https://package.elm-lang.org/packages/mdgriffith/elm-ui/latest/"><code>mdgriffith/elm-ui</code></a> avec son approche sans CSS</li>
<li>utiliser <a href="https://package.elm-lang.org/packages/rtfeldman/elm-css/latest/"><code>rtfeldman/elm-css</code></a> qui propose une approche intéressante de CSS typé nous orientant vers du <em>CSS in Elm</em></li>
</ul>
<p>La curiosité pour cette dernière solution a joué un grand rôle dans le choix malgré ma réticence légendaire pour les solutions de <em>CSS in JavaScript</em>. La première alternative était très semblable à celle que j'ai l'habitude de suivre en JavaScript et je souhaitais changer pour ce projet. Quant à la deuxième option, j'avais déjà eu l'occasion d'utiliser un peu <code>elm-ui</code> et avait eu le sentiment qu'il réglait un problème que je n'avais personnellement pas : j'ai toujours apprécié le CSS et ses possibilités et me sentais un peu contraint par le champs réduit des possibles d'<code>elm-ui</code>. </p>
<p>Nous sommes donc partis sur le fait d'utiliser <code>elm-css</code> avec ces quelques règles simples :</p>
<ul>
<li>chaque composant (ou groupe de composants) a son propre fichier Elm dans lequel on peut trouver le composant et le CSS correspondant</li>
<li>ce CSS est défini de façon globale, c'est-à-dire qu'il génère une feuille de style CSS propre (par opposition au fait de n'utiliser que des styles <em>inline</em>, autre possibilité de <code>elm-css</code>)</li>
<li>les couleurs, typographies et espacements sont dans leur module propre</li>
<li>nos composants doivent être composables : chacun d'eux prend une liste d'attributs et d'enfants comme le ferait n'importe quelle fonction de <code>elm/html</code></li>
</ul>
<p>Petit exemple pour un bouton :</p>
<pre><code class="lang-elm"><span class="hljs-title">button</span> : <span class="hljs-type">ButtonType</span> -&gt; <span class="hljs-type">ButtonSize</span> -&gt; <span class="hljs-type">List</span> (<span class="hljs-type">Html</span>.<span class="hljs-type">Attribute</span> msg) -&gt; <span class="hljs-type">List</span> (<span class="hljs-type">Html</span> msg) -&gt; <span class="hljs-type">Html</span> msg  
<span class="hljs-title">button</span> buttonType buttonSize attributes content =  
    <span class="hljs-keyword">let</span>  
        typeClass =  
            class (getTypeClass buttonType)  

        sizeClass =  
            class (getSizeClass buttonSize)  
    <span class="hljs-keyword">in</span>  
    <span class="hljs-type">Html</span>.button  
        ([ class <span class="hljs-string">"button"</span>, typeClass, sizeClass ] ++ attributes)  
        content

<span class="hljs-title">styles</span> : <span class="hljs-type">List</span> <span class="hljs-type">Css</span>.<span class="hljs-type">Snippet</span>  
<span class="hljs-title">styles</span> =  
    [ <span class="hljs-type">Css</span>.<span class="hljs-type">Global</span>.class <span class="hljs-string">"button"</span>  
        [ borderRadius (px <span class="hljs-number">3</span>)  
        , textTransform uppercase  
        , cursor pointer    
        , textAlign center  
        , withClass <span class="hljs-string">"button--primary"</span>  
            [ backgroundColor <span class="hljs-type">Colors</span>.primary  
            , color <span class="hljs-type">Colors</span>.colorOnPrimary  
            ]    
        , withClass <span class="hljs-string">"button--large"</span>  
            [ padding2 (px <span class="hljs-number">10</span>) (px <span class="hljs-number">16</span>)  
            ]
        <span class="hljs-comment">-- ...     </span>
        ]
    ]
</code></pre>
<p>On voit qu'on a un bouton générique qu'on peut personnaliser avec deux options : son type (primaire, secondaire, ...) et sa taille (large, medium, petit). Avec des fonctions Elm, c'est très simple à réaliser et les types nous aident à limiter les choix possibles !</p>
<p>Les styles sont définis à part puis centralisés entre composants et insérés une fois dans la page.</p>
<p>Une amélioration possible de ce code serait de typer nos classes pour éviter les erreurs d'inattention, mais nous n'avons pas encore ressenti le besoin d'aller jusque là :</p>
<pre><code class="lang-elm"><span class="hljs-keyword">type</span> <span class="hljs-type">ButtonClass</span> =
    <span class="hljs-type">Button</span>
    | <span class="hljs-type">ButtonPrimary</span>
    | <span class="hljs-type">ButtonSecondary</span>
    | <span class="hljs-type">ButtonLarge</span>

<span class="hljs-title">buttonClassToClass</span> : <span class="hljs-type">ButtonClass</span> -&gt; <span class="hljs-type">Html</span>.<span class="hljs-type">Attribute</span> msg
<span class="hljs-title">buttonClassToClass</span> buttonClass = 
    <span class="hljs-keyword">case</span> buttonClass <span class="hljs-keyword">of</span> 
        <span class="hljs-type">Button</span> -&gt;
            class <span class="hljs-string">"button"</span>
        <span class="hljs-type">ButtonPrimary</span> -&gt;
            class <span class="hljs-string">"button--primary"</span>
        <span class="hljs-type">ButtonSecondary</span> -&gt;
            class <span class="hljs-string">"button--secondary"</span>
        <span class="hljs-type">ButtonLarge</span> -&gt;
            class <span class="hljs-string">"button--large"</span>
</code></pre>
<h2 id="les-l-ments-de-base">Les éléments de base</h2>
<p>Un design system commence en général par les atomes, les éléments les plus simples. Nous avons donc commencé par créer un fichier <code>Colors</code> contenant toutes les couleurs de notre projet selon leur sémantique :</p>
<pre><code class="lang-elm"><span class="hljs-title">borderLight</span> : <span class="hljs-type">Color</span>  
<span class="hljs-title">borderLight</span> =  
    rgba <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0.12</span>

<span class="hljs-comment">-- ... </span>

<span class="hljs-title">fieldBorder</span> : <span class="hljs-type">Color</span>  
<span class="hljs-title">fieldBorder</span> =  
    borderLight
</code></pre>
<p>Viennent ensuite les textes. Nous avons choisi d'utiliser une unique fonction pour tous les textes de l'application afin de centraliser toutes les possibilités. Cette fonction s'appelle <code>typography</code> et est utilisée aussi bien dans nos pages que dans nos composants. L'astuce est que cette fonction prend deux arguments essentiels : le type de texte et la balise à utiliser :</p>
<pre><code class="lang-elm"><span class="hljs-keyword">type</span> <span class="hljs-type">TypographyType</span>  
    = <span class="hljs-type">Title1</span>  
    | <span class="hljs-type">Title2</span>  
    | <span class="hljs-type">Paragraph1</span>
    | <span class="hljs-type">Paragraph2</span>
    | <span class="hljs-type">Error</span>

<span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">Tag</span> = 
    <span class="hljs-type">List</span> (<span class="hljs-type">Html</span>.<span class="hljs-type">Attribute</span> msg) -&gt; <span class="hljs-type">List</span> (<span class="hljs-type">Html</span> msg) -&gt; <span class="hljs-type">Html</span> msg

<span class="hljs-title">typography</span> : <span class="hljs-type">TypographyType</span> -&gt; <span class="hljs-type">Tag</span> -&gt; <span class="hljs-type">List</span> (<span class="hljs-type">Html</span>.<span class="hljs-type">Attribute</span> msg) -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Html</span> msg  
<span class="hljs-title">typography</span> typographyType tagFunction attributes content =  
    <span class="hljs-keyword">let</span>  
        className =  
            getClassName typographyType  
    <span class="hljs-keyword">in</span>  
        tagFunction (class className :: attributes) [ text content ]

<span class="hljs-comment">-- Exemple d'utilisation :</span>

<span class="hljs-title">myTitle</span> =
    typography <span class="hljs-type">Title1</span> h2 [] <span class="hljs-string">"My title"</span>
</code></pre>
<p>L'avantage est qu'on peut combiner très facilement style et sémantique : on peut notamment respecter la hiérarchie <code>h1</code>,  <code>h2</code>, etc. sans être contraint au niveau de l'apparence du texte. </p>
<p>De même, les espacements sont codifiés pour avoir un style plus uniforme sur le site :</p>
<pre><code class="lang-elm"><span class="hljs-keyword">type</span> <span class="hljs-type">SpacingSize</span>  
    = <span class="hljs-type">NoSpace</span> | <span class="hljs-type">XXS</span> | <span class="hljs-type">XS</span> | <span class="hljs-type">S</span> | <span class="hljs-type">M</span> | <span class="hljs-type">L</span> | <span class="hljs-type">XL</span>  

<span class="hljs-title">spacing</span> : <span class="hljs-type">SpacingSize</span> -&gt; <span class="hljs-type">Px</span>  
<span class="hljs-title">spacing</span> spacingSize =  
    <span class="hljs-keyword">case</span> spacingSize <span class="hljs-keyword">of</span>  
        <span class="hljs-type">NoSpace</span> -&gt;  
            px <span class="hljs-number">0</span>  
        <span class="hljs-type">XXS</span> -&gt;  
            px <span class="hljs-number">4</span>  
        <span class="hljs-type">XS</span> -&gt;  
            px <span class="hljs-number">8</span>  
        <span class="hljs-type">S</span> -&gt;  
            px <span class="hljs-number">16</span>  
        <span class="hljs-type">M</span> -&gt;  
            px <span class="hljs-number">24</span>  
        <span class="hljs-type">L</span> -&gt;  
            px <span class="hljs-number">40</span>  
        <span class="hljs-type">XL</span> -&gt;  
            px <span class="hljs-number">60</span>

<span class="hljs-comment">-- Exemple d'utilisation (avec elm-css) :</span>

<span class="hljs-title">myTitle</span> =
    typography <span class="hljs-type">Title1</span> h2 
        [ css [ marginTop (spacing <span class="hljs-type">M</span>) ] ] 
        <span class="hljs-string">"My title"</span>
</code></pre>
<h2 id="diff-rentes-approches-de-composants">Différentes approches de composants</h2>
<p>Pour les gens issus des univers React, Angular ou autre, le réflexe de penser en composants est profondément ancré. En Elm cela est tout à fait valable mais il faut en général un peu de temps pour comprendre que la définition de composant diffère considérablement : un composant, ce n'est pas forcément un élément avec un état interne capable de gérer lui-même ses mises à jour.</p>
<p>Comme nous l'avons vu plus haut, un composant peut être une simple fonction ! Et j'irai même plus loin en disant que si vous le pouvez, essayez au maximum de représenter vos composants par une fonction, c'est de loin le type de composants le plus facile à utiliser. </p>
<p>Mais cela ne suffit pas toujours et voici les différents cas que j'ai pu identifier :</p>
<ul>
<li>mon composant n'a pas d'état interne</li>
<li>mon composant a un état interne mais pas d'effet secondaire</li>
<li>mon composant a des effets secondaires internes</li>
</ul>
<p>Je vais revenir sur chacun de ces cas.</p>
<h3 id="mon-composant-n-a-pas-d-tat-interne">Mon composant n'a pas d'état interne</h3>
<p>Si votre composant n'a pas d'état à gérer, c'est de loin le plus simple ! C'est le cas du bouton vu plus haut, qui délègue à celui qui l'utilise la gestion du clic :</p>
<pre><code class="lang-elm"><span class="hljs-title">backButton</span> =
    button <span class="hljs-type">Secondary</span> <span class="hljs-type">Large</span> 
        [ type_ "button", onClick <span class="hljs-type">Back</span> ] 
        [ text <span class="hljs-string">"Back"</span> ]
</code></pre>
<p>Mais par extension, un composant peut ne pas avoir d'état interne parce qu'il est tout à fait légitime que le parent soit en charge de cet état ! Par exemple, nous avons un bouton qui affiche un loader et se désactive une fois cliqué. Pour les requêtes HTTP, nous utilisons<a href="https://package.elm-lang.org/packages/krisajenkins/remotedata/latest/RemoteData">krisajenkins/remotedata</a> sur toute notre application, et donc nous l'utilisons également pour l'état de notre bouton :</p>
<pre><code class="lang-elm"><span class="hljs-title">buttonWithStatus</span> : <span class="hljs-type">RemoteData</span> e a -&gt; <span class="hljs-type">List</span> (<span class="hljs-type">Html</span>.<span class="hljs-type">Attribute</span> msg) -&gt; <span class="hljs-type">List</span> (<span class="hljs-type">Html</span> msg) -&gt; <span class="hljs-type">Html</span> msg  
<span class="hljs-title">buttonWithStatus</span> status attributes content =  
    <span class="hljs-type">Html</span>.button  
        ([ class <span class="hljs-string">"button"</span>  
         , classList [ ( <span class="hljs-string">"button--loading"</span>, <span class="hljs-type">RemoteData</span>.isLoading status ) ]  
         , disabled ( <span class="hljs-type">RemoteData</span>.isLoading status )  
         ]  ++ attributes  
        )  
        (<span class="hljs-keyword">case</span> status <span class="hljs-keyword">of</span>  
            <span class="hljs-type">Loading</span> -&gt;  
                loader  
            _ -&gt;  
                content  
        )
</code></pre>
<p>Comme le composant parent possède la responsabilité sur l'action effectuée, nul besoin d'avoir ce <code>RemoteData</code> dans l'état de notre composant, c'est un argument comme un autre !</p>
<h3 id="mon-composant-a-un-tat-interne-mais-pas-d-effets-secondaires">Mon composant a un état interne mais pas d'effets secondaires</h3>
<p>Certains de nos composants ont tout de même besoin de garder un état interne qui ne devrait pas être stocké dans un composant parent. Par exemple, nos champs texte conservent toujours deux valeurs dans leur état interne : la valeur actuelle du champ et une valeur indiquant si l'utilisateur a déjà interagi avec le champ. </p>
<pre><code class="lang-elm"><span class="hljs-keyword">module</span> Input <span class="hljs-keyword">exposing</span> (<span class="hljs-type">InputModel</span>)

<span class="hljs-keyword">type</span> <span class="hljs-type">InputModel</span>  
    = <span class="hljs-type">InputModel</span> { value : <span class="hljs-type">String</span>, touchStatus : <span class="hljs-type">TouchStatus</span> }
</code></pre>
<p>Une bonne pratique, comme on le voit ci-dessus, est d'utiliser un type opaque : notre module expose le type <code>InputModel</code> mais pas le constructeur <code>InputModel</code> (la nuance est importante, exposer le constructeur se ferait en modifiant la première ligne : <code>module Input exposing (InputModel(..))</code>).</p>
<p>Cela signifie qu'en dehors de notre fichier, le développeur n'est pas capable de modifier lui-même cet état ou d'en créer un : le composant est le seul responsable de son état interne. </p>
<p>Souvent, on voit que dans ces cas là les développeurs Elm vont remettre en place une mini TEA dans le composant en lui créant une fonction <code>init</code>, <code>update</code>, <code>view</code> ainsi que des messages. Or, si effectivement il faut une façon d'initialiser le modèle et une façon de l'afficher, il n'est pas nécessaire d'avoir une fonction d'<code>update</code> ou des messages si votre composant n'a pas d'effet secondaire !</p>
<p>Pour cela, on va renvoyer le nouveau modèle directement dans le message généré, en demandant en argument supplémentaire un message dans lequel le stocker. Voici l'exemple :</p>
<pre><code class="lang-elm"><span class="hljs-title">input</span> : <span class="hljs-type">String</span> -&gt; <span class="hljs-type">InputModel</span> -&gt; (<span class="hljs-type">InputModel</span> -&gt; msg) -&gt; <span class="hljs-type">List</span> (<span class="hljs-type">Html</span>.<span class="hljs-type">Attribute</span> msg) -&gt; <span class="hljs-type">Html</span> msg
<span class="hljs-title">input</span> inputName (<span class="hljs-type">InputModel</span> model) toMsg attributes =  
    input  
        [ class <span class="hljs-string">"input"</span>  
        , type_ "text"  
        , name inputName
        , <span class="hljs-type">Attributes</span>.value model.value
        , onInput (\newValue -&gt; toMsg ( <span class="hljs-type">InputModel</span> { model | value = newValue } ))
        ]  
        []
</code></pre>
<p><em>(Ceci est un exemple très simplifié : notre composant <code>input</code> gère en réalité beaucoup plus de choses : un label, des erreurs, l'état activé / désactivé, etc.)</em></p>
<p>On voit qu'on peut ainsi retourner directement à l'utilisateur le modèle modifié, ce qui est plus simple des deux côtés puisqu'on n'a pas besoin d'utiliser de <code>Html.map</code> ou d'appeler une fonction d'<code>update</code> pour le composant :</p>
<pre><code class="lang-elm"><span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">Model</span> = 
    { inputModel : <span class="hljs-type">Input</span>.<span class="hljs-type">InputModel</span> }

<span class="hljs-title">init</span> : <span class="hljs-type">Model</span> 
<span class="hljs-title">init</span> = 
    { inputModel = <span class="hljs-type">Input</span>.emptyInput }

<span class="hljs-keyword">type</span> <span class="hljs-type">Msg</span> =
    <span class="hljs-type">InputChanged</span> <span class="hljs-type">Input</span>.<span class="hljs-type">Model</span>

<span class="hljs-title">update</span> : <span class="hljs-type">Msg</span> -&gt; <span class="hljs-type">Model</span> -&gt; <span class="hljs-type">Model</span>
<span class="hljs-title">update</span> msg model = 
    <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>
        <span class="hljs-type">InputChanged</span> newModel -&gt;
            { model | inputModel = newModel }

<span class="hljs-title">view</span> : <span class="hljs-type">Model</span> -&gt; <span class="hljs-type">Html</span> msg
<span class="hljs-title">view</span> model =
    <span class="hljs-type">Input</span>.input <span class="hljs-string">"myInput"</span> model.inputModel <span class="hljs-type">InputChanged</span> [] []
</code></pre>
<h3 id="mon-composant-a-un-tat-interne-et-des-effets-secondaires">Mon composant a un état interne et des effets secondaires</h3>
<p>Si votre composant a des effets secondaires qui sont de sa responsabilité propre (et qui n'ont donc pas vocation a être gérés par le parent), il faudra utiliser une forme plus complexe et embarquer une mini Elm Architecture dans votre composant. </p>
<p>Comprenez bien qu'on sort ici l'artillerie lourde : votre composant gère beaucoup plus de responsabilité et devient d'autant moins facile à utiliser. C'est donc la solution à n'utiliser que lorsque le besoin le justifie.</p>
<p>C'est le cas pour notre slider par exemple, dont voici les types exposés (le code étant trop long) :</p>
<pre><code class="lang-elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Model</span> <span class="hljs-comment">-- Model un type opaque</span>

<span class="hljs-keyword">type</span> <span class="hljs-type">Msg</span> <span class="hljs-comment">-- Msg est un type opaque</span>

<span class="hljs-title">init</span> : <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Float</span> -&gt; <span class="hljs-type">Model</span>

<span class="hljs-title">update</span> : <span class="hljs-type">Msg</span> -&gt; <span class="hljs-type">Model</span> -&gt; (<span class="hljs-type">Model</span>, <span class="hljs-type">Cmd</span> <span class="hljs-type">Msg</span>)

<span class="hljs-title">view</span> : <span class="hljs-type">Model</span> -&gt; <span class="hljs-type">Msg</span>

<span class="hljs-title">subscriptions</span> : <span class="hljs-type">Model</span> -&gt; <span class="hljs-type">Sub</span> <span class="hljs-type">Msg</span>

<span class="hljs-title">value</span> : <span class="hljs-type">Model</span> -&gt; <span class="hljs-type">Float</span>
</code></pre>
<p>On  reconnaît ici une <a href="https://guide.elm-lang.org/architecture/">Elm Architecture</a>. L'<code>init</code> prend trois <code>Float</code> en  argument : la valeur initiale, la valeur minimale et la valeur maximale. On reçoit en retour un Model qui est un type opaque. La seule façon de créer et donc d'utiliser notre composant est donc de passer par cette fonction. </p>
<p>Les fonctions <code>update</code>, <code>view</code> et <code>subscriptions</code> sont standards, mais vont produire des messages de type <code>Slider.Msg</code>. Cela signifie que celui qui va les utiliser devra les <em>envelopper</em> dans un message à lui :</p>
<pre><code class="lang-elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Msg</span>  
    = <span class="hljs-type">MessageFromSlider</span> <span class="hljs-type">Slider</span>.<span class="hljs-type">Msg</span>  

<span class="hljs-keyword">type</span> <span class="hljs-keyword">alias</span> <span class="hljs-type">Model</span> =  
    { sliderModel : <span class="hljs-type">Slider</span>.<span class="hljs-type">Model</span> }  

<span class="hljs-title">update</span> : <span class="hljs-type">Msg</span> -&gt; <span class="hljs-type">Model</span> -&gt; ( <span class="hljs-type">Model</span>, <span class="hljs-type">Cmd</span> <span class="hljs-type">Msg</span> )  
<span class="hljs-title">update</span> msg model =  
    <span class="hljs-keyword">case</span> msg <span class="hljs-keyword">of</span>  
        <span class="hljs-type">MessageFromSlider</span> sliderMsg -&gt;  
            <span class="hljs-keyword">let</span>  
                ( newSliderModel, sliderCmd ) =  
                    <span class="hljs-type">Slider</span>.update msg model.sliderModel  
            <span class="hljs-keyword">in</span>    
            ( { model | sliderModel = newSliderModel }  
            , <span class="hljs-type">Cmd</span>.map <span class="hljs-type">MessageFromSlider</span> sliderCmd  
            )

<span class="hljs-title">view</span> : <span class="hljs-type">Model</span> -&gt; <span class="hljs-type">Html</span> <span class="hljs-type">Msg</span>  
<span class="hljs-title">view</span> model =  
    div []  
        [ <span class="hljs-type">Slider</span>.view model.sliderModel  
            |&gt; <span class="hljs-type">Html</span>.map <span class="hljs-type">MessageFromSlider</span>  
        ]

<span class="hljs-title">subscriptions</span> : <span class="hljs-type">Model</span> -&gt; <span class="hljs-type">Sub</span> <span class="hljs-type">Msg</span>  
<span class="hljs-title">subscriptions</span> model =  
    <span class="hljs-type">Slider</span>.subscriptions model.sliderModel  
        |&gt; <span class="hljs-type">Sub</span>.map <span class="hljs-type">MessageFromSlider</span>
</code></pre>
<p>On enveloppe les messages du slider dans un message personnalisé grâce aux fonctions <code>Cmd.map</code>, <code>Html.map</code> et <code>Sub.map</code>. On obtiendra ainsi un message <code>MessageFromSlider</code> qui contient le message du slider. On se charge nous-même de transmettre ce message ainsi que le modèle à la fonction d'<code>update</code> du slider.</p>
<p>Comme on peut le voir, c'est une approche qui nécessite pas mal de code et qui est donc assez lourde. C'est pourquoi il est souvent recommandé de simplifier au maximum ses composants quand c'est possible. C'est un réflexe parfois dur à prendre quand on vient des frameworks JavaScript qui ont tendance à considérer que tout est un composant indépendant.</p>
<h2 id="concr-tiser-son-design-system">Concrétiser son design system</h2>
<p>Réutiliser des composants et les lister dans son code, c'est très bien, mais c'est encore mieux quand on dispose d'une galerie permettant de les passer en revue ! Pour cela, j'ai utilisé le package <a href="https://package.elm-lang.org/packages/kalutheo/elm-ui-explorer/latest"><code>elm-ui-explorer</code></a> de Théophile Kalumbu, un équivalent plus simple de <a href="https://storybook-design-system.netlify.com/?path=/docs/design-system-intro--page">Storybook</a> dans l'univers JavaScript.</p>
<p><a href="https://kalutheo.github.io/elm-ui-explorer/examples/dsm/index.html#Getting%20Started/About/About">Voici un exemple d'un design system avec elm-ui-explorer</a></p>
<p>Les avantages d'avoir cette galerie sont multiples. Premièrement, ils facilitent la discussion avec votre designer en se penchant directement sur l'implémentation que vous avez faite. Ils aident aussi les développeurs lorsqu'ils ont besoin de retrouver des composants ou de revoir les différentes capacités de leurs composants. Pendant la phase de développement, cela offre aussi l'énorme avantage de tester ses composants en totale isolation du reste du code, permettant ainsi de trouver des bugs visuels ou logiques qui auraient été durs à détecter autrement.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Les design system c'est bien. Permettant d'harmoniser l'apparence visuelle de votre site, ils ont surtout de nombreux avantages lors du développement d'un site internet : ils facilitent la création de nouvelles pages, rendent plus productive la collaboration développeur / designer et permettent de détecter plus rapidement des régressions dans les composants de votre site.</p>
<p>En Elm, c'est très pratique. Comme tout est pur dans ce langage, sortir un composant pour le rendre réutilisable est à peu de choses près aussi simple qu'un copier / coller. Et une fois ces composants créés, les grands atouts du langages interviennent également : ils sont faciles à refactorer et simples à faire évoluer puisque le compilateur sera là pour assurer vos arrières.</p>
<p>Cette première expérience de design system en Elm a été pour moi extrêmement positive ! Ce n'était ni mon premier projet Elm, ni mon premier design system, mais la combinaison des deux s'est révélée extrêmement productive. Si cet article a réussi à vous convaincre, c'est à vous de jouer maintenant !</p>
</div></div></div><a class="backLink" href="/blog"><svg version="1.1" class="octicon arrowLeft" width="30" height="30" viewBox="0 0 10 16"><polygon points="6 3 0 8 6 13 6 10 10 10 10 6 6 6" fill-rule="evenodd" fill="black"></polygon></svg>Other articles</a></div></div></div></body></html>