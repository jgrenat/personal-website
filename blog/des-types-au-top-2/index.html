<!DOCTYPE html>
  <html lang="en">
  <head>
    <link rel="stylesheet" href="/style.css">
    
    <link rel="preload" href="/elm.js" as="script">
    <link rel="modulepreload" href="/index.js">
    
    <script defer="defer" src="/elm.js" type="text/javascript"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <script type="module">
import userInit from"/index.js";
let prefetchedPages=[window.location.pathname],initialLocationHash=document.location.hash.replace(/^#/,"");function loadContentAndInitializeApp(){let a=window.location.pathname.replace(/(w)$/,"$1/");a.endsWith("/")||(a+="/");const b=Elm.TemplateModulesBeta.init({flags:{secrets:null,baseUrl:document.baseURI,isPrerendering:!1,isDevServer:!1,isElmDebugMode:!1,contentJson:JSON.parse(document.getElementById("__ELM_PAGES_DATA__").innerHTML),userFlags:userInit.flags()}});return b.ports.toJsPort.subscribe(()=>{loadNamedAnchor()}),b}function loadNamedAnchor(){if(""!==initialLocationHash){const a=document.querySelector(`[name=${initialLocationHash}]`);a&&a.scrollIntoView()}}function prefetchIfNeeded(a){if(a.host===window.location.host&&!prefetchedPages.includes(a.pathname)){prefetchedPages.push(a.pathname),console.log("Preloading...",a.pathname);const b=document.createElement("link");b.setAttribute("as","fetch"),b.setAttribute("rel","prefetch"),b.setAttribute("href",origin+a.pathname+"/content.json"),document.head.appendChild(b)}}const appPromise=new Promise(function(a){document.addEventListener("DOMContentLoaded",()=>{a(loadContentAndInitializeApp())})});userInit.load(appPromise),"function"==typeof connect&&connect(function(a){appPromise.then(b=>{b.ports.fromJsPort.send({contentJson:a})})});const trigger_prefetch=b=>{const c=find_anchor(b.target);c&&c.href&&c.hasAttribute("elm-pages:prefetch")&&prefetchIfNeeded(c)};let mousemove_timeout;const handle_mousemove=a=>{clearTimeout(mousemove_timeout),mousemove_timeout=setTimeout(()=>{trigger_prefetch(a)},20)};addEventListener("touchstart",trigger_prefetch),addEventListener("mousemove",handle_mousemove);function find_anchor(a){for(;a&&"A"!==a.nodeName.toUpperCase();)a=a.parentNode;return a}
    </script>
    <title>ðŸ‡«ðŸ‡·   Des types au top (2) - JoGrenat's Blog</title>
    <meta name="generator" content="elm-pages v2.1.9">
    <link rel="manifest" href="/manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <link rel="canonical" href="https://www.grenat.eu/blog/des-types-au-top-2" />    <meta name="description" content="AprÃ¨s ce premier article sur les types, dÃ©couvrons maintenant les possibilitÃ©s plus avancÃ©es d'un systÃ¨me de types : du type unitaire aux dependents types, tout en passant par les phantom types, voyons ensemble leurs avantages !" />    <meta property="og:image" content="https://www.datocms-assets.com/53557/1630943269-types-2.jpg?fit=crop&max-h=250&max-w=800" />    <meta property="og:image:secure_url" content="https://www.datocms-assets.com/53557/1630943269-types-2.jpg?fit=crop&max-h=250&max-w=800" />    <meta property="og:image:alt" content="ðŸ‡«ðŸ‡·   Des types au top (2)" />    <meta property="og:title" content="ðŸ‡«ðŸ‡·   Des types au top (2)" />    <meta property="og:url" content="https://www.grenat.eu/blog/des-types-au-top-2" />    <meta property="og:description" content="AprÃ¨s ce premier article sur les types, dÃ©couvrons maintenant les possibilitÃ©s plus avancÃ©es d'un systÃ¨me de types : du type unitaire aux dependents types, tout en passant par les phantom types, voyons ensemble leurs avantages !" />    <meta property="og:site_name" content="JoGrenat's Blog" />    <meta property="twitter:card" content="summary" />    <meta property="twitter:title" content="ðŸ‡«ðŸ‡·   Des types au top (2)" />    <meta property="twitter:description" content="AprÃ¨s ce premier article sur les types, dÃ©couvrons maintenant les possibilitÃ©s plus avancÃ©es d'un systÃ¨me de types : du type unitaire aux dependents types, tout en passant par les phantom types, voyons ensemble leurs avantages !" />    <meta property="twitter:image" content="https://www.datocms-assets.com/53557/1630943269-types-2.jpg?fit=crop&max-h=250&max-w=800" />    <meta property="twitter:image:alt" content="ðŸ‡«ðŸ‡·   Des types au top (2)" />    <meta property="og:type" content="website" />    <link rel="sitemap" type="application/xml" href="/sitemap.xml" />    <link rel="icon" sizes="16x16" type="image/png" href="https://www.datocms-assets.com/53557/1629202623-favicon.png?h=16&w=16" />    <link rel="icon" sizes="32x32" type="image/png" href="https://www.datocms-assets.com/53557/1629202623-favicon.png?h=32&w=32" />    <link rel="icon" sizes="96x96" type="image/png" href="https://www.datocms-assets.com/53557/1629202623-favicon.png?h=96&w=96" />    <link rel="icon" sizes="192x192" type="image/png" href="https://www.datocms-assets.com/53557/1629202623-favicon.png?h=192&w=192" />
    <script id="__ELM_PAGES_DATA__" type="application/json">{"staticData":{"420756529":"{\"items\":[{\"id\":{\"videoId\":\"V2DgGyH6D_k\"}},{\"id\":{\"videoId\":\"Zp4p7DiWMuA\"}},{\"id\":{\"videoId\":\"WToGeMIdoSY\"}},{\"id\":{\"videoId\":\"AQkCgGajhxg\"}},{\"id\":{\"videoId\":\"uFzBmBoSrS0\"}}]}","1142833480":"{\"title\":\"[Code in the Unknown] Adding a \\\"cancel\\\" action to a chess game\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/Zp4p7DiWMuA/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/Zp4p7DiWMuA?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"[Code in the Unknown] Adding a &quot;cancel&quot; action to a chess game\\\"></iframe>\"}","2243736650":"{\"title\":\"Discovering Supabase, a Firebase alternative based on PostgreSQL (part 2)\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/V2DgGyH6D_k/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/V2DgGyH6D_k?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Discovering Supabase, a Firebase alternative based on PostgreSQL (part 2)\\\"></iframe>\"}","2730572102":"{\"title\":\"Creating a Elm package for DatoCMS (part 3)\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/uFzBmBoSrS0/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/uFzBmBoSrS0?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Creating a Elm package for DatoCMS (part 3)\\\"></iframe>\"}","2886442429":"{\"title\":\"Discovering Supabase, a Firebase alternative based on PostgreSQL\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/WToGeMIdoSY/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/WToGeMIdoSY?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Discovering Supabase, a Firebase alternative based on PostgreSQL\\\"></iframe>\"}","2986682595":"{\"title\":\"Creating a Elm package for DatoCMS (last part)\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/AQkCgGajhxg/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/AQkCgGajhxg?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Creating a Elm package for DatoCMS (last part)\\\"></iframe>\"}","3644372390":"{\"data\":{\"websiteConfiguration\":{\"name12867311\":\"JoGrenat's Blog\",\"youtubeChannelId12867311\":\"UCROJRWWGrrTmgGF1Wo9OX5w\",\"twitterIcon\":{\"url3832528868\":\"https://www.datocms-assets.com/53557/1632324226-twitterbird.svg\"},\"footerText12867311\":\"*Blog powered by [elm-pages](https://elm-pages.com/)*\"},\"_site\":{\"globalSeo\":{\"fallbackSeo\":{\"image\":{\"url1831060520\":\"https://www.datocms-assets.com/53557/1632838280-capture-d-ecran-2021-09-28-a-16-11-09.png?fit=fill&max-h=150&max-w=300\"}}}}}}","4051845168":"{\"data\":{\"homePage\":{\"picture\":{\"url4062855192\":\"https://www.datocms-assets.com/53557/1630943458-profil-200.jpg?crop64=Zm9jYWxwb2ludCxmYWNlcyxlbnRyb3B5&fit=crop&h=80&mask=ellipse&w=80\"},\"introductionText12867311\":\"Passionate web developer, caring for user experience and code quality. In this blog, I share my discoveries and reflexions.\"},\"article3223906585\":{\"name1875757806\":\"\uD83C\uDDEB\uD83C\uDDF7   Des types au top (2)\",\"banner\":{\"url1984142787\":\"https://www.datocms-assets.com/53557/1630943269-types-2.jpg?fit=crop&max-h=250&max-w=800\"},\"content103746919\":{\"value3343696236\":{\"schema\":\"dast\",\"document\":{\"type\":\"root\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Dans \"},{\"item\":\"51423405\",\"type\":\"itemLink\",\"children\":[{\"type\":\"span\",\"value\":\"mon premier article sur les types\"}]},{\"type\":\"span\",\"value\":\", nous avons vu plusieurs notions : la \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"cardinalit\u00E9\"},{\"type\":\"span\",\"value\":\" d'un type correspond au nombre de valeurs possibles de ce type, les \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"types alg\u00E9briques\"},{\"type\":\"span\",\"value\":\" correspondent au fait de pouvoir \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"multipler\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"additionner\"},{\"type\":\"span\",\"value\":\" les types entre eux (et donc leur cardinalit\u00E9).\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Nous allons voir dans cet article des notions plus avanc\u00E9es pour voir comment on peut jouer avec les types dans nos programmes.\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Le type unitaire\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Jusqu'\u00E0 maintenant, on a r\u00E9ussi \u00E0 cr\u00E9er des types avec un nombre pr\u00E9cis de valeurs possibles gr\u00E2ce aux enums. Par exemple, notre type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"CardValue\"},{\"type\":\"span\",\"value\":\" contenait 13 valeurs possibles :\"}]},{\"code\":\"public enum Value {  \\n  ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING;  \\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"De m\u00EAme, nous connaissons le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"bool\"},{\"type\":\"span\",\"value\":\" qui poss\u00E8de une cardinalit\u00E9 de 2 et \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"pourrait\"},{\"type\":\"span\",\"value\":\" \u00EAtre repr\u00E9sent\u00E9 par un enum \u00E9galement :\"}]},{\"code\":\"public enum Bool {  \\n  TRUE, FALSE; \\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Allons plus loin, et cr\u00E9ons un type de cardinalit\u00E9 1 :\"}]},{\"code\":\"public enum Unit {  \\n  UNIT; \\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"A quoi peut donc nous servir un type contenant une seule valeur ? Intuitivement, on pourrait penser que cela n'a aucune utilit\u00E9 : une variable de ce type ne peut contenir que cette valeur et est donc constante. On peut en r\u00E9alit\u00E9 trouver plusieurs cas d'utilisation !\"}]},{\"type\":\"heading\",\"level\":3,\"children\":[{\"type\":\"span\",\"value\":\"Repr\u00E9senter le \\\"rien\\\"\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Premi\u00E8rement, imaginons qu'on utilise un \"},{\"url\":\"./des-types-au-top#des-applications-d-exception\",\"type\":\"link\",\"children\":[{\"type\":\"span\",\"value\":\"Result\"}]},{\"type\":\"span\",\"value\":\" pour obtenir le r\u00E9sultat d'une op\u00E9ration. Sauf que cette op\u00E9ration ne retourne aucun r\u00E9sultat, juste l'information selon laquelle tout s'est bien d\u00E9roul\u00E9 \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" une erreur indiquant ce qui s'est mal d\u00E9roul\u00E9.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On pourrait donc utiliser le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result<String, Error>\"},{\"type\":\"span\",\"value\":\" en retournant tout le temps une cha\u00EEne de caract\u00E8re vide, mais ce serait \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"mentir\"},{\"type\":\"span\",\"value\":\" sur notre interface. On peut alors plut\u00F4t choisir de retourner le type unitaire que nous avons cr\u00E9\u00E9 : \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result<Unit, Error>\"},{\"type\":\"span\",\"value\":\". L'appelant sait directement que le cas du succ\u00E8s ne contient aucune information exploitable autre que le fait que notre op\u00E9ration soit un succ\u00E8s.\"}]},{\"type\":\"blockquote\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Attention ! Dans beaucoup de langages, le type unitaire est un type d\u00E9j\u00E0 d\u00E9fini et est repr\u00E9sent\u00E9 comme un tuple vide : \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"()\"},{\"type\":\"span\",\"value\":\". On \u00E9crirait ainsi plut\u00F4t \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result<(), Error>\"},{\"type\":\"span\",\"value\":\". Je vais donc utiliser \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"()\"},{\"type\":\"span\",\"value\":\" dans la suite de cet article.\"}]}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Ce cas d'utilisation est tr\u00E8s proche du \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Void\"},{\"type\":\"span\",\"value\":\" dans des langages comme Java, dont la seule valeur possible est la valeur joker \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\". On peut donc s'en servir g\u00E9n\u00E9ralement pour indiquer qu'une fonction ne retourne rien. Rappelez-vous, \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\" n'existe pas dans certains langages et le type alg\u00E9brique \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Maybe\"},{\"type\":\"span\",\"value\":\" qui remplace certains de ses cas d'utilisation sert \u00E0 caract\u00E9riser une fonction qui retourne \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"parfois\"},{\"type\":\"span\",\"value\":\" des valeurs et \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"parfois\"},{\"type\":\"span\",\"value\":\" rien. Ici, avec \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Void\"},{\"type\":\"span\",\"value\":\", on parle de fonctions qui ne renvoient \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"jamais\"},{\"type\":\"span\",\"value\":\" de valeur.\"}]},{\"type\":\"heading\",\"level\":3,\"children\":[{\"type\":\"span\",\"value\":\"Une fonction sans arguments\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Dans les langages fonctionnels, les fonctions sans argument sont g\u00E9n\u00E9ralement des constantes, par exemple en Elm :\"}]},{\"code\":\"myValue = 13\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Les fonctions sont pures et retournent donc toujours la m\u00EAme valeur quand on leur donne les m\u00EAmes arguments. Ce qui explique pourquoi une fonction sans argument est une constante !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Ici, on assigne la valeur 13 \u00E0 notre variable / constante \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"myValue\"},{\"type\":\"span\",\"value\":\". Comme \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"13\"},{\"type\":\"span\",\"value\":\" est une valeur facile \u00E0 calculer, il n'y a aucun probl\u00E8me. Mais que se passe-t-il si la valeur de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"myValue\"},{\"type\":\"span\",\"value\":\" est quelque chose de long ou co\u00FBteux \u00E0 calculer ? Dans ce cas-l\u00E0, on va chercher \u00E0 la calculer seulement quand on en a besoin. De faire ce qu'on appelle du \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"lazy\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Et pour \u00E7a, la solution la plus simple est de mettre un argument qui ne sert \u00E0 rien :\"}]},{\"code\":\"myValue : () -> Int\\nmyValue () = 13 -- remplacer par un calcul long \u00E0 effectuer\\n\\n-- On calcule cette valeur seulement quand on en a besoin :\\nmyOtherValue = myValue ()\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"heading\",\"level\":3,\"children\":[{\"type\":\"span\",\"value\":\"Repr\u00E9senter les entiers naturels\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Cet usage est plus exotique, mais on pourrait s'en servir pour repr\u00E9senter une liste d'entier naturels, \u00E0 savoir ici \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"0, 1, 2, 3, 4...\"},{\"type\":\"span\",\"value\":\". Ce n'est en g\u00E9n\u00E9ral pas possible dans les langages de programmation ne poss\u00E9dant pas de type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"unsigned int\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Alors comment faire ? Imaginons que nous mettions notre type unitaire dans une liste (\"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"List<()>\"},{\"type\":\"span\",\"value\":\"), on pourrait donc avoir une liste \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"[(), ()]\"},{\"type\":\"span\",\"value\":\" ou \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"[(), (), (), ()]\"},{\"type\":\"span\",\"value\":\" ou m\u00EAme une liste vide \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"[]\"},{\"type\":\"span\",\"value\":\". Comme chaque \u00E9l\u00E9ment de cette liste est forc\u00E9ment le type unitaire, la seule information que cette liste peut nous donner, c'est sa \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"taille\"},{\"type\":\"span\",\"value\":\". Or, la taille d'une liste est pr\u00E9cis\u00E9ment une liste d'entier naturels du type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"0, 1, 2, 3, 4...\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On pourrait donc impl\u00E9menter un type bas\u00E9 sur une liste du type unitaire qui nous garantirait d'avoir uniquement des entiers positifs ou z\u00E9ro !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Dans la r\u00E9alit\u00E9, on utilise plut\u00F4t un type alg\u00E9brique pour repr\u00E9senter les entiers naturels :\"}]},{\"code\":\"type NaturalInt = \\n  Zero\\n  | Succ NaturalInt\\n\\nzero = Zero\\none = Succ Zero\\ntwo = Succ (Succ Zero)\\n-- ...\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Le type vide\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Un type avec une cardinalit\u00E9 de 1 peut donc nous \u00EAtre utile, mais qu'en est-il d'un type de cardinalit\u00E9 0, qui ne poss\u00E8de donc aucune valeur ? \u00C9tonnamment, ce genre de type a \u00E9galement des utilit\u00E9s ! Mais voyons comment d\u00E9finir ce genre de type en Haskell :\"}]},{\"code\":\"data Void\",\"type\":\"code\",\"language\":\"haskell\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On d\u00E9finit ici un type alg\u00E9brique sans aucune valeur possible. En Elm, cette syntaxe n'est pas possible, on a donc recours \u00E0 une petite astuce pour cr\u00E9er le type vide \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Never\"},{\"type\":\"span\",\"value\":\" :\"}]},{\"code\":\"type Never = JustOneMore Never\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On a donc bien un constructeur pr\u00E9sent (\"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"JustOneMore\"},{\"type\":\"span\",\"value\":\"), mais celui-ci contient un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Never\"},{\"type\":\"span\",\"value\":\", on doit donc lui donner une valeur en utilisant le constructeur \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"JustOneMore\"},{\"type\":\"span\",\"value\":\" qui doit lui-m\u00EAme contenir un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Never\"},{\"type\":\"span\",\"value\":\". On entre dans une r\u00E9cursion infinie et il est donc impossible de cr\u00E9er une valeur de ce type.\"}]},{\"type\":\"heading\",\"level\":3,\"children\":[{\"type\":\"span\",\"value\":\"Le cas impossible\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Mais alors quelle peut \u00EAtre l'utilit\u00E9 de ce type qu'on ne peut pas utiliser ? Eh bien justement de d\u00E9montrer que quelque chose est impossible !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Imaginons que notre fonction retourne un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result\"},{\"type\":\"span\",\"value\":\" pour une raison pr\u00E9cise (pour se conformer \u00E0 une interface par exemple) mais que cette fonction ne peut pas \u00E9chouer (il n'y a aucun cas d'erreur possible). On pourrait signifier que ce r\u00E9sultat est forc\u00E9ment valide en utilisant \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result<MyResult, Void>\"},{\"type\":\"span\",\"value\":\". Comme il est impossible de cr\u00E9er une valeur de type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Void\"},{\"type\":\"span\",\"value\":\", le r\u00E9sultat sera forc\u00E9ment toujours de type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Ok MyResult\"},{\"type\":\"span\",\"value\":\". Notre certitude est donc prouv\u00E9e par notre syst\u00E8me de type et v\u00E9rifi\u00E9e par le compilateur.\"}]},{\"type\":\"heading\",\"level\":3,\"children\":[{\"type\":\"span\",\"value\":\"Ne m'attendez pas !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Void\"},{\"type\":\"span\",\"value\":\" peut \u00E9galement \u00EAtre utilis\u00E9 en retour de fonction, avec une cons\u00E9quence in\u00E9luctable : cette fonction ne peut jamais retourner de valeur ! La fonction ne peut donc pas se terminer de la fonction habituelle. Dans certains langages, cela peut vouloir dire que la fonction a une autre fa\u00E7on de se terminer (renvoyer une exception par exemple). Mais cela peut aussi vouloir dire que cette fonction ne va jamais se terminer (boucle infinie) ! On pourrait ainsi repr\u00E9senter une fonction charg\u00E9e de calculer une \u00E0 une les d\u00E9cimales de pi en les affichant au fur et \u00E0 mesure. Comme il y en a une infinit\u00E9, cette fonction ne se terminerait jamais !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"L'utilisation du type vide peut donc \u00EAtre une indication de boucle infinie volontaire. Le type porte ainsi une information suppl\u00E9mentaire sur notre programme qui est v\u00E9rifi\u00E9e par le compilateur.\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Les types fant\u00F4mes\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Le type vide peut \u00E9galement \u00EAtre utilis\u00E9 pour d'autres usages : les types fant\u00F4mes \u2013 \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"phantom types\"},{\"type\":\"span\",\"value\":\" en anglais. Ce terme fait r\u00E9f\u00E9rence \u00E0 des param\u00E8tre de types non utilis\u00E9s dans la d\u00E9finition du type. Un exemple sera plus parlant. Ici, nous avons un type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"PasswordInput\"},{\"type\":\"span\",\"value\":\" utilis\u00E9 pour stocker le password saisi par un utilisateur dans un formulaire lorsqu'il veut s'enregistrer sur notre site. L'exemple est en Elm :\"}]},{\"code\":\"type PasswordInput a = Value String\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On passe en param\u00E8tre de la d\u00E9finition de notre type un type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"a\"},{\"type\":\"span\",\"value\":\" qu'on n'utilise pas dans la d\u00E9finition \u00E0 droite. Mais alors \u00E0 quoi sert-il ? Eh bien cela devient tr\u00E8s utile lorsqu'on n'expose pas directement le constructeur \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\" et qu'on expose \u00E0 la place une fonction \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"createInputValue\"},{\"type\":\"span\",\"value\":\". Cette fonction est donc la seule fa\u00E7on de cr\u00E9er un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"PasswordInput\"},{\"type\":\"span\",\"value\":\" :\"}]},{\"code\":\"type NotValidated = NotValidated\\ntype Validated = Validated\\n\\ncreateInputValue : String -> PasswordInput NotValidated\\ncreateInputValue value =\\n    Value value\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Ici, \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"NotValidated\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Validated\"},{\"type\":\"span\",\"value\":\" sont deux types unitaires qui ne vont \u00EAtre utilis\u00E9s que dans nos signatures de type pour \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"taguer\"},{\"type\":\"span\",\"value\":\" notre type, indiquant s'il a \u00E9t\u00E9 valid\u00E9 ou non. Ici, on cr\u00E9e un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"PasswordInput NotValidated\"},{\"type\":\"span\",\"value\":\", notre type de retour comporte donc l'information que cet input n'a pas \u00E9t\u00E9 valid\u00E9. Comme ces deux types sont l\u00E0 uniquement pour les signatures de type et non pour leurs valeurs, on peut expliciter ce fait en les rendant non instanciables gr\u00E2ce au type vide \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Never\"},{\"type\":\"span\",\"value\":\":\"}]},{\"code\":\"type NotValidated = NotValidated Never\\ntype Validated = Validated Never\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Cr\u00E9ant maintenant une fonction de validation dont le but sera de modifier ce \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"tag\"},{\"type\":\"span\",\"value\":\" si l'input est valide :\"}]},{\"code\":\"type Error = InvalidPassword\\n\\nvalidatePassword : PasswordInput NotValidated -> Result Error (PasswordInput Validated)\\nvalidatePassword (Value password) =\\n    if isValid password then\\n        Ok (Value password)\\n    else\\n        Err InvalidPassword\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"La fonction \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"validatePassword\"},{\"type\":\"span\",\"value\":\" permet de modifier le tag si le password est valide ou de retourner une erreur dans le cas inverse. Elle prend \u00E9galement en argument un password tagu\u00E9 \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"NotValidated\"},{\"type\":\"span\",\"value\":\" : avec un email identifi\u00E9 comme \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Validated\"},{\"type\":\"span\",\"value\":\", on ne pourrait pas utiliser cette fonction. Cette v\u00E9rification se fait \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"au moment de la compilation\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On peut noter qu'on ne change en rien la \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"valeur\"},{\"type\":\"span\",\"value\":\" de notre input, mais uniquement son \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"type\"},{\"type\":\"span\",\"value\":\", qui agit donc en marqueur pour savoir s'il a \u00E9t\u00E9 valid\u00E9.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Enfin, voici la signature de la fonction permettant l'enregistrement du mot de passe c\u00F4t\u00E9 backend :\"}]},{\"code\":\"saveNewPassword : PasswordInput Validated -> Cmd Msg\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Comme on le voit, on peut ici inscrire dans notre syst\u00E8me de type que notre password est bien valide, donc qu'il a pass\u00E9 avec succ\u00E8s la phase de validation de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"validatePassword\"},{\"type\":\"span\",\"value\":\". Et puisque le compilateur va v\u00E9rifier cette contrainte, on peut s'y fier !\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Les dependent types\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Avec les phantom types, on se rend compte qu'il est possible de jouer sur le \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"type\"},{\"type\":\"span\",\"value\":\" plut\u00F4t que sur la \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"valeur\"},{\"type\":\"span\",\"value\":\" pour faire porter une information suppl\u00E9mentaire \u00E0 notre donn\u00E9e. Cependant, nous n'avons jamais m\u00E9lang\u00E9 \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"valeur\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"type\"},{\"type\":\"span\",\"value\":\" ; ceux-ci sont toujours rigoureusement s\u00E9par\u00E9s.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Imaginons qu'on poss\u00E8de un tableau de 5 \u00E9l\u00E9ments, et qu'on cherche \u00E0 r\u00E9cup\u00E9rer le 5\u00E8me \u00E9l\u00E9ment. Les indices commencent \u00E0 0, on cherche donc \u00E0 r\u00E9cup\u00E9rer l'\u00E9l\u00E9ment \u00E0 l'index 4 gr\u00E2ce \u00E0 la fonction \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"index\"},{\"type\":\"span\",\"value\":\" :\"}]},{\"code\":\"fifthElement = index 4 my5Elements\",\"type\":\"code\",\"language\":\"idris\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Jusqu'ici tout va bien, et on r\u00E9cup\u00E8re effectivement notre 5\u00E8me \u00E9l\u00E9ment. Mais que se passerait-il si on essayait de r\u00E9cup\u00E9rer le 6\u00E8me \u00E9l\u00E9ment ?\"}]},{\"code\":\"sixthElement = index 5 my5Elements\",\"type\":\"code\",\"language\":\"idris\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Dans la plupart des langages, ce code va d\u00E9clencher une exception du style \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"OutOfBoundException\"},{\"type\":\"span\",\"value\":\". Dans certains autres langages, la fonction \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"index\"},{\"type\":\"span\",\"value\":\" retourne un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Maybe\"},{\"type\":\"span\",\"value\":\" ou un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Either\"},{\"type\":\"span\",\"value\":\" pour repr\u00E9senter la possibilit\u00E9 d'erreur. En \"},{\"url\":\"https://www.idris-lang.org/\",\"type\":\"link\",\"children\":[{\"type\":\"span\",\"value\":\"Idris\"}]},{\"type\":\"span\",\"value\":\", en revanche, ce dernier bout de code \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ne compile pas\"},{\"type\":\"span\",\"value\":\" !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Comment est-ce possible ? Tout simplement parce que notre tableau d'\u00E9l\u00E9ments (on appelle \u00E7a un vecteur \u2014 \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Vect\"},{\"type\":\"span\",\"value\":\" \u2014 en Idris) est d\u00E9fini comme ceci :\"}]},{\"code\":\"my5Elements : Vect 5 Element\\nmy5Elements = One :: Two :: Three :: Four :: Five :: Nil\",\"type\":\"code\",\"language\":\"idris\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Le type est tr\u00E8s particulier : on voit un nombre \u2013 et donc une \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"valeur\"},{\"type\":\"span\",\"value\":\" \u2013 pour indiquer que ce \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Vect\"},{\"type\":\"span\",\"value\":\" contient 5 \u00E9l\u00E9ments ! C'est ce qu'on appelle un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"dependent type\"},{\"type\":\"span\",\"value\":\" \u2013 possible notamment en Idris \u2013 ce qui fait que le compilateur est capable de v\u00E9rifier si l'index auquel on cherche \u00E0 acc\u00E9der est valide ou non !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"En v\u00E9rit\u00E9, la fonction \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"index\"},{\"type\":\"span\",\"value\":\" est d\u00E9finie gr\u00E2ce au type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Fin n\"},{\"type\":\"span\",\"value\":\" qui repr\u00E9sente les entiers naturels ou nuls strictement inf\u00E9rieurs \u00E0 \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"n\"},{\"type\":\"span\",\"value\":\". Par exemple \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Fin 5\"},{\"type\":\"span\",\"value\":\" est un type qui contient les valeurs suivantes : \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"0, 1, 2, 3, 4\"},{\"type\":\"span\",\"value\":\". Voici le type de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"index\"},{\"type\":\"span\",\"value\":\" :\"}]},{\"code\":\"index : Fin n -> Vect n e -> e\",\"type\":\"code\",\"language\":\"idris\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On ne pourra donc jamais utiliser un nombre invalide pour acc\u00E9der \u00E0 l'index d'un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Vect\"},{\"type\":\"span\",\"value\":\", et si on souhaite utiliser une valeur dynamique comme index, il faudra d'abord prouver qu'elle est dans l'interval d\u00E9sir\u00E9 !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Idris est cependant principalement un langage utilis\u00E9 dans la recherche et n'est pas destin\u00E9 \u00E0 construire des applications grand public en production. C'est pourtant le langage le plus \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"utilisable\"},{\"type\":\"span\",\"value\":\" comportant des \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"dependent types\"},{\"type\":\"span\",\"value\":\" aujourd'hui. De plus, l'\u00E9tape de compilation est tr\u00E8s lente \u00E0 cause de toute la complexit\u00E9 suppl\u00E9mentaire.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Cela reste cependant un exemple int\u00E9ressant de ce que peuvent permettre des syst\u00E8mes de type.\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Conclusion\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"La plupart des langages les plus utilis\u00E9s aujourd'hui poss\u00E8dent un \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"type system\"},{\"type\":\"span\",\"value\":\" basique. Sans types alg\u00E9briques, il est par exemple compliqu\u00E9 de mod\u00E9liser exactement notre m\u00E9tier sans y incorporer de nombreux cas impossibles.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On note cependant depuis peu une \u00E9mergence de langages au \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"type system\"},{\"type\":\"span\",\"value\":\" plus avanc\u00E9, comme TypeScript (m\u00EAme s'il est tr\u00E8s facile de tricher dans ce langage), Swift, Kotlin et Rust. Et c'est \u00E0 mon sens une tr\u00E8s bonne chose !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On voit qu'il est bien souvent possible d'inscrire dans nos types nos exigences et r\u00E8gles m\u00E9tiers. Le code s'en retrouve plus lisible et plus coh\u00E9rent. Am\u00E9liorer sa mod\u00E9lisation permet d'am\u00E9liorer la compr\u00E9hension qu'on a de son code et diminue du m\u00EAme coup la charge cognitive n\u00E9cessaire pour le comprendre.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Chaque \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Maybe\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Either\"},{\"type\":\"span\",\"value\":\", par exemple, peut repr\u00E9senter de l'incertitude. Et quand on commence \u00E0 mod\u00E9liser son incertitude, on r\u00E9alise rapidement que nos codebases en sont remplies. C'est \u00E0 ce moment pr\u00E9cis qu'on peut alors chercher \u00E0 la r\u00E9duire, en utilisant au maximum nos types.\"}]}]}},\"blocks\":[],\"links\":[{\"id1492635460\":\"51423405\",\"name12867311\":\"\uD83C\uDDEB\uD83C\uDDF7  Des types au top\",\"slug12867311\":\"des-types-au-top\"}]},\"description12867311\":\"Apr\u00E8s ce premier article sur les types, d\u00E9couvrons maintenant les possibilit\u00E9s plus avanc\u00E9es d'un syst\u00E8me de types : du type unitaire aux dependents types, tout en passant par les phantom types, voyons ensemble leurs avantages !\",\"bannerAttribution\":[]}}}"},"is404":false,"path":"blog/des-types-au-top-2"}</script>
    </head>
    <body>
      <div data-url="" display="none"></div>
      <div><span class="elm-css-style-wrapper" style="display: none;"><style></style></span><span class="elm-css-style-wrapper" style="display: none;"><style>.footer{padding-top:0;padding-bottom:0;font-size:1rem;}
.footerContent{margin:1rem 0;}
.footerContent  h2{font-size:2.2rem;font-weight:900;text-align:left;margin:3.5rem 0 1rem;}
.footerContent  h3{font-size:1.8rem;font-weight:600;text-align:left;margin:3vh 0 1vh;color:rgba(0,0,0,0.8);}
.footerContent  h4{font-size:1.2rem;font-weight:200;text-align:left;margin:2vh 0 1vh;color:rgba(0,0,0,0.6);}
.footerContent  p{margin:2.5rem 0;line-height:2rem;white-space:pre-wrap;text-align:justify;color:rgba(0,0,0,0.8);}
.footerContent  p > code{background-color:rgba(225,225,255,0.7);padding:1px 3px;font-size:0.7em;}
.footerContent  blockquote{border-left:5px solid rgba(5,117,230,0.8);background-color:rgba(5,117,230,0.1);padding:0.01vh 1vw;max-width:650px;margin:2.5rem auto;}
@media only screen and (max-width: 600px){.footerContent  blockquote{border-left:0;border-top:5px solid rgba(5,117,230,0.8);padding:0.01vh 3vw;}}
.footerContent  blockquote > p:first-child{margin-top:1rem;}
.footerContent  blockquote > p:last-child{margin-bottom:1rem;}
.footerContent  strong{font-weight:900;color:rgb(0,0,0);}
.footerContent  em{font-style:italic;}
.footerContent  a{text-decoration:underline;}
.footerContent  a:hover{text-decoration:none;}
.footerContent  .thanks{margin-top:2vw;font-style:italic;font-size:0.8em;text-align:right;}
.footerContent  ul{list-style-type:disc;padding-left:1rem;margin-left:2vh;}
.footerContent  ul > li + li{margin-top:2vh;}
.footerContent  pre{max-width:100%;overflow-y:scroll;}
.footerContent  code{line-height:1.7rem;font-size:0.85em;}
.footerContent  img{max-width:100%;}
.footerContent  img.fullWidth{width:100%;}
.footerContent > :first-child{margin-top:0;}
.footerContent > :last-child{margin-bottom:0;}
.footerContent  p{text-align:right;}</style></span><main class="container"><span class="elm-css-style-wrapper" style="display: none;"><style>.site-title{display:flex;justify-content:space-between;align-items:center;font-size:1.5rem;margin:0.5rem 0 2rem;}
.site-title  a{text-decoration:none;}
.site-title  img{width:2rem;transition:transform 100ms  ;}
.site-title  img:hover{transform:scale(1.5);}
.site-title  .site-name{transition:transform 100ms  ;transform-origin:center left;}
.site-title  .site-name:hover{transform:scale(1.1);}
.article{margin-top:20px;}
.article  .article-title{font-size:3rem;text-align:center;margin-bottom:3rem;font-weight:900;}
.article  .article-banner{width:100%;padding-top:31.25%;position:relative;}
.article  .article-banner.article-banner--withAttribution{margin-bottom:4rem;}
.article  .article-banner.article-banner--withAttribution  figcaption{position:absolute;top:103%;left:0;width:100%;text-align:center;font-size:0.8rem;color:rgba(0,0,0,0.7);}
.article  .article-banner.article-banner--withAttribution  figcaption  em{font-style:italic;}
.article  .article-banner  img{position:absolute;top:0;left:0;width:100%;height:100%;}
.article  .article-content{margin-bottom:5vh;}
.article  .article-content  h2{font-size:2.2rem;font-weight:900;text-align:left;margin:3.5rem 0 1rem;}
.article  .article-content  h3{font-size:1.8rem;font-weight:600;text-align:left;margin:3vh 0 1vh;color:rgba(0,0,0,0.8);}
.article  .article-content  h4{font-size:1.2rem;font-weight:200;text-align:left;margin:2vh 0 1vh;color:rgba(0,0,0,0.6);}
.article  .article-content  p{margin:2.5rem 0;line-height:2rem;white-space:pre-wrap;text-align:justify;color:rgba(0,0,0,0.8);}
.article  .article-content  p > code{background-color:rgba(225,225,255,0.7);padding:1px 3px;font-size:0.7em;}
.article  .article-content  blockquote{border-left:5px solid rgba(5,117,230,0.8);background-color:rgba(5,117,230,0.1);padding:0.01vh 1vw;max-width:650px;margin:2.5rem auto;}
@media only screen and (max-width: 600px){.article  .article-content  blockquote{border-left:0;border-top:5px solid rgba(5,117,230,0.8);padding:0.01vh 3vw;}}
.article  .article-content  blockquote > p:first-child{margin-top:1rem;}
.article  .article-content  blockquote > p:last-child{margin-bottom:1rem;}
.article  .article-content  strong{font-weight:900;color:rgb(0,0,0);}
.article  .article-content  em{font-style:italic;}
.article  .article-content  a{text-decoration:underline;}
.article  .article-content  a:hover{text-decoration:none;}
.article  .article-content  .thanks{margin-top:2vw;font-style:italic;font-size:0.8em;text-align:right;}
.article  .article-content  ul{list-style-type:disc;padding-left:1rem;margin-left:2vh;}
.article  .article-content  ul > li + li{margin-top:2vh;}
.article  .article-content  pre{max-width:100%;overflow-y:scroll;}
.article  .article-content  code{line-height:1.7rem;font-size:0.85em;}
.article  .article-content  img{max-width:100%;}
.article  .article-content  img.fullWidth{width:100%;}
.author-card{display:flex;align-items:center;margin-top:2.5rem;}
.author-card > .author-picture{margin-right:1rem;}
.author-card > .author-description{text-align:justify;font-size:1rem;line-height:1.5rem;}</style></span><div class="site-title"><a class="site-name" elm-pages:prefetch="" href="/">JoGrenat&#039;s Blog</a><a href="https://twitter.com/JoGrenat"><img src="https://www.datocms-assets.com/53557/1632324226-twitterbird.svg"></a></div><section class="article"><h1 class="article-title">ðŸ‡«ðŸ‡·   Des types au top (2)</h1><figure class="article-banner " aria-hidden="true"><img alt="" src="https://www.datocms-assets.com/53557/1630943269-types-2.jpg?fit=crop&max-h=250&max-w=800"></figure><div class="article-content"><div><p>Dans <a elm-pages:prefetch="" href="/blog/des-types-au-top"><span class="elm-css-style-wrapper" style="display: none;"><style></style></span><span>mon premier article sur les types</span></a>, nous avons vu plusieurs notions : la <strong>cardinalitÃ©</strong> d&#039;un type correspond au nombre de valeurs possibles de ce type, les <strong>types algÃ©briques</strong> correspondent au fait de pouvoir <em>multipler</em> et <em>additionner</em> les types entre eux (et donc leur cardinalitÃ©).</p><p>Nous allons voir dans cet article des notions plus avancÃ©es pour voir comment on peut jouer avec les types dans nos programmes.</p><h2>Le type unitaire</h2><p>Jusqu&#039;Ã  maintenant, on a rÃ©ussi Ã  crÃ©er des types avec un nombre prÃ©cis de valeurs possibles grÃ¢ce aux enums. Par exemple, notre type <code>CardValue</code> contenait 13 valeurs possibles :</p><pre><code class="lang-java">public enum Value {  
  ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING;  
}</code></pre><p>De mÃªme, nous connaissons le type <code>bool</code> qui possÃ¨de une cardinalitÃ© de 2 et <em>pourrait</em> Ãªtre reprÃ©sentÃ© par un enum Ã©galement :</p><pre><code class="lang-java">public enum Bool {  
  TRUE, FALSE; 
}</code></pre><p>Allons plus loin, et crÃ©ons un type de cardinalitÃ© 1 :</p><pre><code class="lang-java">public enum Unit {  
  UNIT; 
}</code></pre><p>A quoi peut donc nous servir un type contenant une seule valeur ? Intuitivement, on pourrait penser que cela n&#039;a aucune utilitÃ© : une variable de ce type ne peut contenir que cette valeur et est donc constante. On peut en rÃ©alitÃ© trouver plusieurs cas d&#039;utilisation !</p><h3>ReprÃ©senter le &quot;rien&quot;</h3><p>PremiÃ¨rement, imaginons qu&#039;on utilise un <a href="./des-types-au-top#des-applications-d-exception">Result</a> pour obtenir le rÃ©sultat d&#039;une opÃ©ration. Sauf que cette opÃ©ration ne retourne aucun rÃ©sultat, juste l&#039;information selon laquelle tout s&#039;est bien dÃ©roulÃ© <em>ou</em> une erreur indiquant ce qui s&#039;est mal dÃ©roulÃ©.</p><p>On pourrait donc utiliser le type <code>Result&lt;String, Error&gt;</code> en retournant tout le temps une chaÃ®ne de caractÃ¨re vide, mais ce serait <em>mentir</em> sur notre interface. On peut alors plutÃ´t choisir de retourner le type unitaire que nous avons crÃ©Ã© : <code>Result&lt;Unit, Error&gt;</code>. L&#039;appelant sait directement que le cas du succÃ¨s ne contient aucune information exploitable autre que le fait que notre opÃ©ration soit un succÃ¨s.</p><blockquote><p>Attention ! Dans beaucoup de langages, le type unitaire est un type dÃ©jÃ  dÃ©fini et est reprÃ©sentÃ© comme un tuple vide : <code>()</code>. On Ã©crirait ainsi plutÃ´t <code>Result&lt;(), Error&gt;</code>. Je vais donc utiliser <code>()</code> dans la suite de cet article.</p></blockquote><p>Ce cas d&#039;utilisation est trÃ¨s proche du <code>Void</code> dans des langages comme Java, dont la seule valeur possible est la valeur joker <code>null</code>. On peut donc s&#039;en servir gÃ©nÃ©ralement pour indiquer qu&#039;une fonction ne retourne rien. Rappelez-vous, <code>null</code> n&#039;existe pas dans certains langages et le type algÃ©brique <code>Maybe</code> qui remplace certains de ses cas d&#039;utilisation sert Ã  caractÃ©riser une fonction qui retourne <em>parfois</em> des valeurs et <em>parfois</em> rien. Ici, avec <code>Void</code>, on parle de fonctions qui ne renvoient <em>jamais</em> de valeur.</p><h3>Une fonction sans arguments</h3><p>Dans les langages fonctionnels, les fonctions sans argument sont gÃ©nÃ©ralement des constantes, par exemple en Elm :</p><pre><code class="lang-elm">myValue = 13</code></pre><p>Les fonctions sont pures et retournent donc toujours la mÃªme valeur quand on leur donne les mÃªmes arguments. Ce qui explique pourquoi une fonction sans argument est une constante !</p><p>Ici, on assigne la valeur 13 Ã  notre variable / constante <code>myValue</code>. Comme <code>13</code> est une valeur facile Ã  calculer, il n&#039;y a aucun problÃ¨me. Mais que se passe-t-il si la valeur de <code>myValue</code> est quelque chose de long ou coÃ»teux Ã  calculer ? Dans ce cas-lÃ , on va chercher Ã  la calculer seulement quand on en a besoin. De faire ce qu&#039;on appelle du <code>lazy</code>.</p><p>Et pour Ã§a, la solution la plus simple est de mettre un argument qui ne sert Ã  rien :</p><pre><code class="lang-elm">myValue : () -&gt; Int
myValue () = 13 -- remplacer par un calcul long Ã  effectuer

-- On calcule cette valeur seulement quand on en a besoin :
myOtherValue = myValue ()</code></pre><h3>ReprÃ©senter les entiers naturels</h3><p>Cet usage est plus exotique, mais on pourrait s&#039;en servir pour reprÃ©senter une liste d&#039;entier naturels, Ã  savoir ici <code>0, 1, 2, 3, 4...</code>. Ce n&#039;est en gÃ©nÃ©ral pas possible dans les langages de programmation ne possÃ©dant pas de type <code>unsigned int</code>.</p><p>Alors comment faire ? Imaginons que nous mettions notre type unitaire dans une liste (<code>List&lt;()&gt;</code>), on pourrait donc avoir une liste <code>[(), ()]</code> ou <code>[(), (), (), ()]</code> ou mÃªme une liste vide <code>[]</code>. Comme chaque Ã©lÃ©ment de cette liste est forcÃ©ment le type unitaire, la seule information que cette liste peut nous donner, c&#039;est sa <em>taille</em>. Or, la taille d&#039;une liste est prÃ©cisÃ©ment une liste d&#039;entier naturels du type <code>0, 1, 2, 3, 4...</code>.</p><p>On pourrait donc implÃ©menter un type basÃ© sur une liste du type unitaire qui nous garantirait d&#039;avoir uniquement des entiers positifs ou zÃ©ro !</p><p>Dans la rÃ©alitÃ©, on utilise plutÃ´t un type algÃ©brique pour reprÃ©senter les entiers naturels :</p><pre><code class="lang-elm">type NaturalInt = 
  Zero
  | Succ NaturalInt

zero = Zero
one = Succ Zero
two = Succ (Succ Zero)
-- ...</code></pre><h2>Le type vide</h2><p>Un type avec une cardinalitÃ© de 1 peut donc nous Ãªtre utile, mais qu&#039;en est-il d&#039;un type de cardinalitÃ© 0, qui ne possÃ¨de donc aucune valeur ? Ã‰tonnamment, ce genre de type a Ã©galement des utilitÃ©s ! Mais voyons comment dÃ©finir ce genre de type en Haskell :</p><pre><code class="lang-haskell">data Void</code></pre><p>On dÃ©finit ici un type algÃ©brique sans aucune valeur possible. En Elm, cette syntaxe n&#039;est pas possible, on a donc recours Ã  une petite astuce pour crÃ©er le type vide <code>Never</code> :</p><pre><code class="lang-elm">type Never = JustOneMore Never</code></pre><p>On a donc bien un constructeur prÃ©sent (<code>JustOneMore</code>), mais celui-ci contient un <code>Never</code>, on doit donc lui donner une valeur en utilisant le constructeur <code>JustOneMore</code> qui doit lui-mÃªme contenir un <code>Never</code>. On entre dans une rÃ©cursion infinie et il est donc impossible de crÃ©er une valeur de ce type.</p><h3>Le cas impossible</h3><p>Mais alors quelle peut Ãªtre l&#039;utilitÃ© de ce type qu&#039;on ne peut pas utiliser ? Eh bien justement de dÃ©montrer que quelque chose est impossible !</p><p>Imaginons que notre fonction retourne un <code>Result</code> pour une raison prÃ©cise (pour se conformer Ã  une interface par exemple) mais que cette fonction ne peut pas Ã©chouer (il n&#039;y a aucun cas d&#039;erreur possible). On pourrait signifier que ce rÃ©sultat est forcÃ©ment valide en utilisant <code>Result&lt;MyResult, Void&gt;</code>. Comme il est impossible de crÃ©er une valeur de type <code>Void</code>, le rÃ©sultat sera forcÃ©ment toujours de type <code>Ok MyResult</code>. Notre certitude est donc prouvÃ©e par notre systÃ¨me de type et vÃ©rifiÃ©e par le compilateur.</p><h3>Ne m&#039;attendez pas !</h3><p><code>Void</code> peut Ã©galement Ãªtre utilisÃ© en retour de fonction, avec une consÃ©quence inÃ©luctable : cette fonction ne peut jamais retourner de valeur ! La fonction ne peut donc pas se terminer de la fonction habituelle. Dans certains langages, cela peut vouloir dire que la fonction a une autre faÃ§on de se terminer (renvoyer une exception par exemple). Mais cela peut aussi vouloir dire que cette fonction ne va jamais se terminer (boucle infinie) ! On pourrait ainsi reprÃ©senter une fonction chargÃ©e de calculer une Ã  une les dÃ©cimales de pi en les affichant au fur et Ã  mesure. Comme il y en a une infinitÃ©, cette fonction ne se terminerait jamais !</p><p>L&#039;utilisation du type vide peut donc Ãªtre une indication de boucle infinie volontaire. Le type porte ainsi une information supplÃ©mentaire sur notre programme qui est vÃ©rifiÃ©e par le compilateur.</p><h2>Les types fantÃ´mes</h2><p>Le type vide peut Ã©galement Ãªtre utilisÃ© pour d&#039;autres usages : les types fantÃ´mes â€“ <em>phantom types</em> en anglais. Ce terme fait rÃ©fÃ©rence Ã  des paramÃ¨tre de types non utilisÃ©s dans la dÃ©finition du type. Un exemple sera plus parlant. Ici, nous avons un type <code>PasswordInput</code> utilisÃ© pour stocker le password saisi par un utilisateur dans un formulaire lorsqu&#039;il veut s&#039;enregistrer sur notre site. L&#039;exemple est en Elm :</p><pre><code class="lang-elm">type PasswordInput a = Value String</code></pre><p>On passe en paramÃ¨tre de la dÃ©finition de notre type un type <code>a</code> qu&#039;on n&#039;utilise pas dans la dÃ©finition Ã  droite. Mais alors Ã  quoi sert-il ? Eh bien cela devient trÃ¨s utile lorsqu&#039;on n&#039;expose pas directement le constructeur <code>Value</code> et qu&#039;on expose Ã  la place une fonction <code>createInputValue</code>. Cette fonction est donc la seule faÃ§on de crÃ©er un <code>PasswordInput</code> :</p><pre><code class="lang-elm">type NotValidated = NotValidated
type Validated = Validated

createInputValue : String -&gt; PasswordInput NotValidated
createInputValue value =
    Value value</code></pre><p>Ici, <code>NotValidated</code> et <code>Validated</code> sont deux types unitaires qui ne vont Ãªtre utilisÃ©s que dans nos signatures de type pour <strong>taguer</strong> notre type, indiquant s&#039;il a Ã©tÃ© validÃ© ou non. Ici, on crÃ©e un <code>PasswordInput NotValidated</code>, notre type de retour comporte donc l&#039;information que cet input n&#039;a pas Ã©tÃ© validÃ©. Comme ces deux types sont lÃ  uniquement pour les signatures de type et non pour leurs valeurs, on peut expliciter ce fait en les rendant non instanciables grÃ¢ce au type vide <code>Never</code>:</p><pre><code class="lang-elm">type NotValidated = NotValidated Never
type Validated = Validated Never</code></pre><p>CrÃ©ant maintenant une fonction de validation dont le but sera de modifier ce <em>tag</em> si l&#039;input est valide :</p><pre><code class="lang-elm">type Error = InvalidPassword

validatePassword : PasswordInput NotValidated -&gt; Result Error (PasswordInput Validated)
validatePassword (Value password) =
    if isValid password then
        Ok (Value password)
    else
        Err InvalidPassword</code></pre><p>La fonction <code>validatePassword</code> permet de modifier le tag si le password est valide ou de retourner une erreur dans le cas inverse. Elle prend Ã©galement en argument un password taguÃ© <code>NotValidated</code> : avec un email identifiÃ© comme <code>Validated</code>, on ne pourrait pas utiliser cette fonction. Cette vÃ©rification se fait <em>au moment de la compilation</em>.</p><p>On peut noter qu&#039;on ne change en rien la <em>valeur</em> de notre input, mais uniquement son <em>type</em>, qui agit donc en marqueur pour savoir s&#039;il a Ã©tÃ© validÃ©.</p><p>Enfin, voici la signature de la fonction permettant l&#039;enregistrement du mot de passe cÃ´tÃ© backend :</p><pre><code class="lang-elm">saveNewPassword : PasswordInput Validated -&gt; Cmd Msg</code></pre><p>Comme on le voit, on peut ici inscrire dans notre systÃ¨me de type que notre password est bien valide, donc qu&#039;il a passÃ© avec succÃ¨s la phase de validation de <code>validatePassword</code>. Et puisque le compilateur va vÃ©rifier cette contrainte, on peut s&#039;y fier !</p><h2>Les dependent types</h2><p>Avec les phantom types, on se rend compte qu&#039;il est possible de jouer sur le <em>type</em> plutÃ´t que sur la <em>valeur</em> pour faire porter une information supplÃ©mentaire Ã  notre donnÃ©e. Cependant, nous n&#039;avons jamais mÃ©langÃ© <em>valeur</em> et <em>type</em> ; ceux-ci sont toujours rigoureusement sÃ©parÃ©s.</p><p>Imaginons qu&#039;on possÃ¨de un tableau de 5 Ã©lÃ©ments, et qu&#039;on cherche Ã  rÃ©cupÃ©rer le 5Ã¨me Ã©lÃ©ment. Les indices commencent Ã  0, on cherche donc Ã  rÃ©cupÃ©rer l&#039;Ã©lÃ©ment Ã  l&#039;index 4 grÃ¢ce Ã  la fonction <code>index</code> :</p><pre><code class="lang-idris">fifthElement = index 4 my5Elements</code></pre><p>Jusqu&#039;ici tout va bien, et on rÃ©cupÃ¨re effectivement notre 5Ã¨me Ã©lÃ©ment. Mais que se passerait-il si on essayait de rÃ©cupÃ©rer le 6Ã¨me Ã©lÃ©ment ?</p><pre><code class="lang-idris">sixthElement = index 5 my5Elements</code></pre><p>Dans la plupart des langages, ce code va dÃ©clencher une exception du style <code>OutOfBoundException</code>. Dans certains autres langages, la fonction <code>index</code> retourne un <code>Maybe</code> ou un <code>Either</code> pour reprÃ©senter la possibilitÃ© d&#039;erreur. En <a href="https://www.idris-lang.org/">Idris</a>, en revanche, ce dernier bout de code <strong>ne compile pas</strong> !</p><p>Comment est-ce possible ? Tout simplement parce que notre tableau d&#039;Ã©lÃ©ments (on appelle Ã§a un vecteur â€” <code>Vect</code> â€” en Idris) est dÃ©fini comme ceci :</p><pre><code class="lang-idris">my5Elements : Vect 5 Element
my5Elements = One :: Two :: Three :: Four :: Five :: Nil</code></pre><p>Le type est trÃ¨s particulier : on voit un nombre â€“ et donc une <em>valeur</em> â€“ pour indiquer que ce <code>Vect</code> contient 5 Ã©lÃ©ments ! C&#039;est ce qu&#039;on appelle un <code>dependent type</code> â€“ possible notamment en Idris â€“ ce qui fait que le compilateur est capable de vÃ©rifier si l&#039;index auquel on cherche Ã  accÃ©der est valide ou non !</p><p>En vÃ©ritÃ©, la fonction <code>index</code> est dÃ©finie grÃ¢ce au type <code>Fin n</code> qui reprÃ©sente les entiers naturels ou nuls strictement infÃ©rieurs Ã  <code>n</code>. Par exemple <code>Fin 5</code> est un type qui contient les valeurs suivantes : <code>0, 1, 2, 3, 4</code>. Voici le type de <code>index</code> :</p><pre><code class="lang-idris">index : Fin n -&gt; Vect n e -&gt; e</code></pre><p>On ne pourra donc jamais utiliser un nombre invalide pour accÃ©der Ã  l&#039;index d&#039;un <code>Vect</code>, et si on souhaite utiliser une valeur dynamique comme index, il faudra d&#039;abord prouver qu&#039;elle est dans l&#039;interval dÃ©sirÃ© !</p><p>Idris est cependant principalement un langage utilisÃ© dans la recherche et n&#039;est pas destinÃ© Ã  construire des applications grand public en production. C&#039;est pourtant le langage le plus <em>utilisable</em> comportant des <em>dependent types</em> aujourd&#039;hui. De plus, l&#039;Ã©tape de compilation est trÃ¨s lente Ã  cause de toute la complexitÃ© supplÃ©mentaire.</p><p>Cela reste cependant un exemple intÃ©ressant de ce que peuvent permettre des systÃ¨mes de type.</p><h2>Conclusion</h2><p>La plupart des langages les plus utilisÃ©s aujourd&#039;hui possÃ¨dent un <em>type system</em> basique. Sans types algÃ©briques, il est par exemple compliquÃ© de modÃ©liser exactement notre mÃ©tier sans y incorporer de nombreux cas impossibles.</p><p>On note cependant depuis peu une Ã©mergence de langages au <em>type system</em> plus avancÃ©, comme TypeScript (mÃªme s&#039;il est trÃ¨s facile de tricher dans ce langage), Swift, Kotlin et Rust. Et c&#039;est Ã  mon sens une trÃ¨s bonne chose !</p><p>On voit qu&#039;il est bien souvent possible d&#039;inscrire dans nos types nos exigences et rÃ¨gles mÃ©tiers. Le code s&#039;en retrouve plus lisible et plus cohÃ©rent. AmÃ©liorer sa modÃ©lisation permet d&#039;amÃ©liorer la comprÃ©hension qu&#039;on a de son code et diminue du mÃªme coup la charge cognitive nÃ©cessaire pour le comprendre.</p><p>Chaque <code>Maybe</code> et <code>Either</code>, par exemple, peut reprÃ©senter de l&#039;incertitude. Et quand on commence Ã  modÃ©liser son incertitude, on rÃ©alise rapidement que nos codebases en sont remplies. C&#039;est Ã  ce moment prÃ©cis qu&#039;on peut alors chercher Ã  la rÃ©duire, en utilisant au maximum nos types.</p></div></div></section><aside class="author-card"><img class="author-picture" src="https://www.datocms-assets.com/53557/1630943458-profil-200.jpg?crop64=Zm9jYWxwb2ludCxmYWNlcyxlbnRyb3B5&fit=crop&h=80&mask=ellipse&w=80"><p class="author-description">Passionate web developer, caring for user experience and code quality. In this blog, I share my discoveries and reflexions.</p></aside></main><footer class="container footer"><div class="footerContent"><p><em>Blog powered by <a href="https://elm-pages.com/">elm-pages</a></em></p></div></footer></div>
    </body>
  </html>
  