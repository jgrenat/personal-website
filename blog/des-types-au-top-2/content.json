{"is404":false,"staticData":{"420756529":"{\"items\":[{\"id\":{\"videoId\":\"V2DgGyH6D_k\"}},{\"id\":{\"videoId\":\"Zp4p7DiWMuA\"}},{\"id\":{\"videoId\":\"WToGeMIdoSY\"}},{\"id\":{\"videoId\":\"AQkCgGajhxg\"}},{\"id\":{\"videoId\":\"uFzBmBoSrS0\"}}]}","1142833480":"{\"title\":\"[Code in the Unknown] Adding a \\\"cancel\\\" action to a chess game\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/Zp4p7DiWMuA/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/Zp4p7DiWMuA?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"[Code in the Unknown] Adding a &quot;cancel&quot; action to a chess game\\\"></iframe>\"}","2243736650":"{\"title\":\"Discovering Supabase, a Firebase alternative based on PostgreSQL (part 2)\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/V2DgGyH6D_k/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/V2DgGyH6D_k?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Discovering Supabase, a Firebase alternative based on PostgreSQL (part 2)\\\"></iframe>\"}","2730572102":"{\"title\":\"Creating a Elm package for DatoCMS (part 3)\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/uFzBmBoSrS0/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/uFzBmBoSrS0?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Creating a Elm package for DatoCMS (part 3)\\\"></iframe>\"}","2886442429":"{\"title\":\"Discovering Supabase, a Firebase alternative based on PostgreSQL\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/WToGeMIdoSY/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/WToGeMIdoSY?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Discovering Supabase, a Firebase alternative based on PostgreSQL\\\"></iframe>\"}","2986682595":"{\"title\":\"Creating a Elm package for DatoCMS (last part)\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/AQkCgGajhxg/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/AQkCgGajhxg?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Creating a Elm package for DatoCMS (last part)\\\"></iframe>\"}","3644372390":"{\"data\":{\"websiteConfiguration\":{\"name12867311\":\"JoGrenat's Blog\",\"youtubeChannelId12867311\":\"UCROJRWWGrrTmgGF1Wo9OX5w\",\"twitterIcon\":{\"url3832528868\":\"https://www.datocms-assets.com/53557/1632324226-twitterbird.svg\"},\"footerText12867311\":\"*Blog powered by [elm-pages](https://elm-pages.com/)*\"},\"_site\":{\"globalSeo\":{\"fallbackSeo\":{\"image\":{\"url1831060520\":\"https://www.datocms-assets.com/53557/1632838280-capture-d-ecran-2021-09-28-a-16-11-09.png?fit=fill&max-h=150&max-w=300\"}}}}}}","4051845168":"{\"data\":{\"homePage\":{\"picture\":{\"url4062855192\":\"https://www.datocms-assets.com/53557/1630943458-profil-200.jpg?crop64=Zm9jYWxwb2ludCxmYWNlcyxlbnRyb3B5&fit=crop&h=80&mask=ellipse&w=80\"},\"introductionText12867311\":\"Passionate web developer, caring for user experience and code quality. In this blog, I share my discoveries and reflexions.\"},\"article3223906585\":{\"name1875757806\":\"üá´üá∑   Des types au top (2)\",\"banner\":{\"url1984142787\":\"https://www.datocms-assets.com/53557/1630943269-types-2.jpg?fit=crop&max-h=250&max-w=800\"},\"content103746919\":{\"value3343696236\":{\"schema\":\"dast\",\"document\":{\"type\":\"root\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Dans \"},{\"item\":\"51423405\",\"type\":\"itemLink\",\"children\":[{\"type\":\"span\",\"value\":\"mon premier article sur les types\"}]},{\"type\":\"span\",\"value\":\", nous avons vu plusieurs notions : la \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"cardinalit√©\"},{\"type\":\"span\",\"value\":\" d'un type correspond au nombre de valeurs possibles de ce type, les \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"types alg√©briques\"},{\"type\":\"span\",\"value\":\" correspondent au fait de pouvoir \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"multipler\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"additionner\"},{\"type\":\"span\",\"value\":\" les types entre eux (et donc leur cardinalit√©).\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Nous allons voir dans cet article des notions plus avanc√©es pour voir comment on peut jouer avec les types dans nos programmes.\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Le type unitaire\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Jusqu'√† maintenant, on a r√©ussi √† cr√©er des types avec un nombre pr√©cis de valeurs possibles gr√¢ce aux enums. Par exemple, notre type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"CardValue\"},{\"type\":\"span\",\"value\":\" contenait 13 valeurs possibles :\"}]},{\"code\":\"public enum Value {  \\n  ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING;  \\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"De m√™me, nous connaissons le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"bool\"},{\"type\":\"span\",\"value\":\" qui poss√®de une cardinalit√© de 2 et \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"pourrait\"},{\"type\":\"span\",\"value\":\" √™tre repr√©sent√© par un enum √©galement :\"}]},{\"code\":\"public enum Bool {  \\n  TRUE, FALSE; \\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Allons plus loin, et cr√©ons un type de cardinalit√© 1 :\"}]},{\"code\":\"public enum Unit {  \\n  UNIT; \\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"A quoi peut donc nous servir un type contenant une seule valeur ? Intuitivement, on pourrait penser que cela n'a aucune utilit√© : une variable de ce type ne peut contenir que cette valeur et est donc constante. On peut en r√©alit√© trouver plusieurs cas d'utilisation !\"}]},{\"type\":\"heading\",\"level\":3,\"children\":[{\"type\":\"span\",\"value\":\"Repr√©senter le \\\"rien\\\"\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Premi√®rement, imaginons qu'on utilise un \"},{\"url\":\"./des-types-au-top#des-applications-d-exception\",\"type\":\"link\",\"children\":[{\"type\":\"span\",\"value\":\"Result\"}]},{\"type\":\"span\",\"value\":\" pour obtenir le r√©sultat d'une op√©ration. Sauf que cette op√©ration ne retourne aucun r√©sultat, juste l'information selon laquelle tout s'est bien d√©roul√© \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" une erreur indiquant ce qui s'est mal d√©roul√©.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On pourrait donc utiliser le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result<String, Error>\"},{\"type\":\"span\",\"value\":\" en retournant tout le temps une cha√Æne de caract√®re vide, mais ce serait \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"mentir\"},{\"type\":\"span\",\"value\":\" sur notre interface. On peut alors plut√¥t choisir de retourner le type unitaire que nous avons cr√©√© : \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result<Unit, Error>\"},{\"type\":\"span\",\"value\":\". L'appelant sait directement que le cas du succ√®s ne contient aucune information exploitable autre que le fait que notre op√©ration soit un succ√®s.\"}]},{\"type\":\"blockquote\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Attention ! Dans beaucoup de langages, le type unitaire est un type d√©j√† d√©fini et est repr√©sent√© comme un tuple vide : \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"()\"},{\"type\":\"span\",\"value\":\". On √©crirait ainsi plut√¥t \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result<(), Error>\"},{\"type\":\"span\",\"value\":\". Je vais donc utiliser \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"()\"},{\"type\":\"span\",\"value\":\" dans la suite de cet article.\"}]}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Ce cas d'utilisation est tr√®s proche du \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Void\"},{\"type\":\"span\",\"value\":\" dans des langages comme Java, dont la seule valeur possible est la valeur joker \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\". On peut donc s'en servir g√©n√©ralement pour indiquer qu'une fonction ne retourne rien. Rappelez-vous, \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\" n'existe pas dans certains langages et le type alg√©brique \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Maybe\"},{\"type\":\"span\",\"value\":\" qui remplace certains de ses cas d'utilisation sert √† caract√©riser une fonction qui retourne \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"parfois\"},{\"type\":\"span\",\"value\":\" des valeurs et \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"parfois\"},{\"type\":\"span\",\"value\":\" rien. Ici, avec \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Void\"},{\"type\":\"span\",\"value\":\", on parle de fonctions qui ne renvoient \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"jamais\"},{\"type\":\"span\",\"value\":\" de valeur.\"}]},{\"type\":\"heading\",\"level\":3,\"children\":[{\"type\":\"span\",\"value\":\"Une fonction sans arguments\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Dans les langages fonctionnels, les fonctions sans argument sont g√©n√©ralement des constantes, par exemple en Elm :\"}]},{\"code\":\"myValue = 13\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Les fonctions sont pures et retournent donc toujours la m√™me valeur quand on leur donne les m√™mes arguments. Ce qui explique pourquoi une fonction sans argument est une constante !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Ici, on assigne la valeur 13 √† notre variable / constante \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"myValue\"},{\"type\":\"span\",\"value\":\". Comme \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"13\"},{\"type\":\"span\",\"value\":\" est une valeur facile √† calculer, il n'y a aucun probl√®me. Mais que se passe-t-il si la valeur de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"myValue\"},{\"type\":\"span\",\"value\":\" est quelque chose de long ou co√ªteux √† calculer ? Dans ce cas-l√†, on va chercher √† la calculer seulement quand on en a besoin. De faire ce qu'on appelle du \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"lazy\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Et pour √ßa, la solution la plus simple est de mettre un argument qui ne sert √† rien :\"}]},{\"code\":\"myValue : () -> Int\\nmyValue () = 13 -- remplacer par un calcul long √† effectuer\\n\\n-- On calcule cette valeur seulement quand on en a besoin :\\nmyOtherValue = myValue ()\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"heading\",\"level\":3,\"children\":[{\"type\":\"span\",\"value\":\"Repr√©senter les entiers naturels\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Cet usage est plus exotique, mais on pourrait s'en servir pour repr√©senter une liste d'entier naturels, √† savoir ici \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"0, 1, 2, 3, 4...\"},{\"type\":\"span\",\"value\":\". Ce n'est en g√©n√©ral pas possible dans les langages de programmation ne poss√©dant pas de type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"unsigned int\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Alors comment faire ? Imaginons que nous mettions notre type unitaire dans une liste (\"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"List<()>\"},{\"type\":\"span\",\"value\":\"), on pourrait donc avoir une liste \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"[(), ()]\"},{\"type\":\"span\",\"value\":\" ou \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"[(), (), (), ()]\"},{\"type\":\"span\",\"value\":\" ou m√™me une liste vide \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"[]\"},{\"type\":\"span\",\"value\":\". Comme chaque √©l√©ment de cette liste est forc√©ment le type unitaire, la seule information que cette liste peut nous donner, c'est sa \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"taille\"},{\"type\":\"span\",\"value\":\". Or, la taille d'une liste est pr√©cis√©ment une liste d'entier naturels du type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"0, 1, 2, 3, 4...\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On pourrait donc impl√©menter un type bas√© sur une liste du type unitaire qui nous garantirait d'avoir uniquement des entiers positifs ou z√©ro !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Dans la r√©alit√©, on utilise plut√¥t un type alg√©brique pour repr√©senter les entiers naturels :\"}]},{\"code\":\"type NaturalInt = \\n  Zero\\n  | Succ NaturalInt\\n\\nzero = Zero\\none = Succ Zero\\ntwo = Succ (Succ Zero)\\n-- ...\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Le type vide\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Un type avec une cardinalit√© de 1 peut donc nous √™tre utile, mais qu'en est-il d'un type de cardinalit√© 0, qui ne poss√®de donc aucune valeur ? √âtonnamment, ce genre de type a √©galement des utilit√©s ! Mais voyons comment d√©finir ce genre de type en Haskell :\"}]},{\"code\":\"data Void\",\"type\":\"code\",\"language\":\"haskell\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On d√©finit ici un type alg√©brique sans aucune valeur possible. En Elm, cette syntaxe n'est pas possible, on a donc recours √† une petite astuce pour cr√©er le type vide \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Never\"},{\"type\":\"span\",\"value\":\" :\"}]},{\"code\":\"type Never = JustOneMore Never\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On a donc bien un constructeur pr√©sent (\"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"JustOneMore\"},{\"type\":\"span\",\"value\":\"), mais celui-ci contient un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Never\"},{\"type\":\"span\",\"value\":\", on doit donc lui donner une valeur en utilisant le constructeur \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"JustOneMore\"},{\"type\":\"span\",\"value\":\" qui doit lui-m√™me contenir un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Never\"},{\"type\":\"span\",\"value\":\". On entre dans une r√©cursion infinie et il est donc impossible de cr√©er une valeur de ce type.\"}]},{\"type\":\"heading\",\"level\":3,\"children\":[{\"type\":\"span\",\"value\":\"Le cas impossible\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Mais alors quelle peut √™tre l'utilit√© de ce type qu'on ne peut pas utiliser ? Eh bien justement de d√©montrer que quelque chose est impossible !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Imaginons que notre fonction retourne un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result\"},{\"type\":\"span\",\"value\":\" pour une raison pr√©cise (pour se conformer √† une interface par exemple) mais que cette fonction ne peut pas √©chouer (il n'y a aucun cas d'erreur possible). On pourrait signifier que ce r√©sultat est forc√©ment valide en utilisant \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result<MyResult, Void>\"},{\"type\":\"span\",\"value\":\". Comme il est impossible de cr√©er une valeur de type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Void\"},{\"type\":\"span\",\"value\":\", le r√©sultat sera forc√©ment toujours de type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Ok MyResult\"},{\"type\":\"span\",\"value\":\". Notre certitude est donc prouv√©e par notre syst√®me de type et v√©rifi√©e par le compilateur.\"}]},{\"type\":\"heading\",\"level\":3,\"children\":[{\"type\":\"span\",\"value\":\"Ne m'attendez pas !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Void\"},{\"type\":\"span\",\"value\":\" peut √©galement √™tre utilis√© en retour de fonction, avec une cons√©quence in√©luctable : cette fonction ne peut jamais retourner de valeur ! La fonction ne peut donc pas se terminer de la fonction habituelle. Dans certains langages, cela peut vouloir dire que la fonction a une autre fa√ßon de se terminer (renvoyer une exception par exemple). Mais cela peut aussi vouloir dire que cette fonction ne va jamais se terminer (boucle infinie) ! On pourrait ainsi repr√©senter une fonction charg√©e de calculer une √† une les d√©cimales de pi en les affichant au fur et √† mesure. Comme il y en a une infinit√©, cette fonction ne se terminerait jamais !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"L'utilisation du type vide peut donc √™tre une indication de boucle infinie volontaire. Le type porte ainsi une information suppl√©mentaire sur notre programme qui est v√©rifi√©e par le compilateur.\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Les types fant√¥mes\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Le type vide peut √©galement √™tre utilis√© pour d'autres usages : les types fant√¥mes ‚Äì \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"phantom types\"},{\"type\":\"span\",\"value\":\" en anglais. Ce terme fait r√©f√©rence √† des param√®tre de types non utilis√©s dans la d√©finition du type. Un exemple sera plus parlant. Ici, nous avons un type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"PasswordInput\"},{\"type\":\"span\",\"value\":\" utilis√© pour stocker le password saisi par un utilisateur dans un formulaire lorsqu'il veut s'enregistrer sur notre site. L'exemple est en Elm :\"}]},{\"code\":\"type PasswordInput a = Value String\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On passe en param√®tre de la d√©finition de notre type un type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"a\"},{\"type\":\"span\",\"value\":\" qu'on n'utilise pas dans la d√©finition √† droite. Mais alors √† quoi sert-il ? Eh bien cela devient tr√®s utile lorsqu'on n'expose pas directement le constructeur \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\" et qu'on expose √† la place une fonction \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"createInputValue\"},{\"type\":\"span\",\"value\":\". Cette fonction est donc la seule fa√ßon de cr√©er un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"PasswordInput\"},{\"type\":\"span\",\"value\":\" :\"}]},{\"code\":\"type NotValidated = NotValidated\\ntype Validated = Validated\\n\\ncreateInputValue : String -> PasswordInput NotValidated\\ncreateInputValue value =\\n    Value value\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Ici, \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"NotValidated\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Validated\"},{\"type\":\"span\",\"value\":\" sont deux types unitaires qui ne vont √™tre utilis√©s que dans nos signatures de type pour \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"taguer\"},{\"type\":\"span\",\"value\":\" notre type, indiquant s'il a √©t√© valid√© ou non. Ici, on cr√©e un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"PasswordInput NotValidated\"},{\"type\":\"span\",\"value\":\", notre type de retour comporte donc l'information que cet input n'a pas √©t√© valid√©. Comme ces deux types sont l√† uniquement pour les signatures de type et non pour leurs valeurs, on peut expliciter ce fait en les rendant non instanciables gr√¢ce au type vide \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Never\"},{\"type\":\"span\",\"value\":\":\"}]},{\"code\":\"type NotValidated = NotValidated Never\\ntype Validated = Validated Never\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Cr√©ant maintenant une fonction de validation dont le but sera de modifier ce \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"tag\"},{\"type\":\"span\",\"value\":\" si l'input est valide :\"}]},{\"code\":\"type Error = InvalidPassword\\n\\nvalidatePassword : PasswordInput NotValidated -> Result Error (PasswordInput Validated)\\nvalidatePassword (Value password) =\\n    if isValid password then\\n        Ok (Value password)\\n    else\\n        Err InvalidPassword\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"La fonction \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"validatePassword\"},{\"type\":\"span\",\"value\":\" permet de modifier le tag si le password est valide ou de retourner une erreur dans le cas inverse. Elle prend √©galement en argument un password tagu√© \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"NotValidated\"},{\"type\":\"span\",\"value\":\" : avec un email identifi√© comme \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Validated\"},{\"type\":\"span\",\"value\":\", on ne pourrait pas utiliser cette fonction. Cette v√©rification se fait \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"au moment de la compilation\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On peut noter qu'on ne change en rien la \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"valeur\"},{\"type\":\"span\",\"value\":\" de notre input, mais uniquement son \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"type\"},{\"type\":\"span\",\"value\":\", qui agit donc en marqueur pour savoir s'il a √©t√© valid√©.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Enfin, voici la signature de la fonction permettant l'enregistrement du mot de passe c√¥t√© backend :\"}]},{\"code\":\"saveNewPassword : PasswordInput Validated -> Cmd Msg\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Comme on le voit, on peut ici inscrire dans notre syst√®me de type que notre password est bien valide, donc qu'il a pass√© avec succ√®s la phase de validation de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"validatePassword\"},{\"type\":\"span\",\"value\":\". Et puisque le compilateur va v√©rifier cette contrainte, on peut s'y fier !\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Les dependent types\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Avec les phantom types, on se rend compte qu'il est possible de jouer sur le \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"type\"},{\"type\":\"span\",\"value\":\" plut√¥t que sur la \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"valeur\"},{\"type\":\"span\",\"value\":\" pour faire porter une information suppl√©mentaire √† notre donn√©e. Cependant, nous n'avons jamais m√©lang√© \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"valeur\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"type\"},{\"type\":\"span\",\"value\":\" ; ceux-ci sont toujours rigoureusement s√©par√©s.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Imaginons qu'on poss√®de un tableau de 5 √©l√©ments, et qu'on cherche √† r√©cup√©rer le 5√®me √©l√©ment. Les indices commencent √† 0, on cherche donc √† r√©cup√©rer l'√©l√©ment √† l'index 4 gr√¢ce √† la fonction \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"index\"},{\"type\":\"span\",\"value\":\" :\"}]},{\"code\":\"fifthElement = index 4 my5Elements\",\"type\":\"code\",\"language\":\"idris\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Jusqu'ici tout va bien, et on r√©cup√®re effectivement notre 5√®me √©l√©ment. Mais que se passerait-il si on essayait de r√©cup√©rer le 6√®me √©l√©ment ?\"}]},{\"code\":\"sixthElement = index 5 my5Elements\",\"type\":\"code\",\"language\":\"idris\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Dans la plupart des langages, ce code va d√©clencher une exception du style \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"OutOfBoundException\"},{\"type\":\"span\",\"value\":\". Dans certains autres langages, la fonction \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"index\"},{\"type\":\"span\",\"value\":\" retourne un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Maybe\"},{\"type\":\"span\",\"value\":\" ou un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Either\"},{\"type\":\"span\",\"value\":\" pour repr√©senter la possibilit√© d'erreur. En \"},{\"url\":\"https://www.idris-lang.org/\",\"type\":\"link\",\"children\":[{\"type\":\"span\",\"value\":\"Idris\"}]},{\"type\":\"span\",\"value\":\", en revanche, ce dernier bout de code \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ne compile pas\"},{\"type\":\"span\",\"value\":\" !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Comment est-ce possible ? Tout simplement parce que notre tableau d'√©l√©ments (on appelle √ßa un vecteur ‚Äî \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Vect\"},{\"type\":\"span\",\"value\":\" ‚Äî en Idris) est d√©fini comme ceci :\"}]},{\"code\":\"my5Elements : Vect 5 Element\\nmy5Elements = One :: Two :: Three :: Four :: Five :: Nil\",\"type\":\"code\",\"language\":\"idris\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Le type est tr√®s particulier : on voit un nombre ‚Äì et donc une \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"valeur\"},{\"type\":\"span\",\"value\":\" ‚Äì pour indiquer que ce \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Vect\"},{\"type\":\"span\",\"value\":\" contient 5 √©l√©ments ! C'est ce qu'on appelle un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"dependent type\"},{\"type\":\"span\",\"value\":\" ‚Äì possible notamment en Idris ‚Äì ce qui fait que le compilateur est capable de v√©rifier si l'index auquel on cherche √† acc√©der est valide ou non !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"En v√©rit√©, la fonction \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"index\"},{\"type\":\"span\",\"value\":\" est d√©finie gr√¢ce au type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Fin n\"},{\"type\":\"span\",\"value\":\" qui repr√©sente les entiers naturels ou nuls strictement inf√©rieurs √† \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"n\"},{\"type\":\"span\",\"value\":\". Par exemple \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Fin 5\"},{\"type\":\"span\",\"value\":\" est un type qui contient les valeurs suivantes : \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"0, 1, 2, 3, 4\"},{\"type\":\"span\",\"value\":\". Voici le type de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"index\"},{\"type\":\"span\",\"value\":\" :\"}]},{\"code\":\"index : Fin n -> Vect n e -> e\",\"type\":\"code\",\"language\":\"idris\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On ne pourra donc jamais utiliser un nombre invalide pour acc√©der √† l'index d'un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Vect\"},{\"type\":\"span\",\"value\":\", et si on souhaite utiliser une valeur dynamique comme index, il faudra d'abord prouver qu'elle est dans l'interval d√©sir√© !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Idris est cependant principalement un langage utilis√© dans la recherche et n'est pas destin√© √† construire des applications grand public en production. C'est pourtant le langage le plus \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"utilisable\"},{\"type\":\"span\",\"value\":\" comportant des \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"dependent types\"},{\"type\":\"span\",\"value\":\" aujourd'hui. De plus, l'√©tape de compilation est tr√®s lente √† cause de toute la complexit√© suppl√©mentaire.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Cela reste cependant un exemple int√©ressant de ce que peuvent permettre des syst√®mes de type.\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Conclusion\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"La plupart des langages les plus utilis√©s aujourd'hui poss√®dent un \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"type system\"},{\"type\":\"span\",\"value\":\" basique. Sans types alg√©briques, il est par exemple compliqu√© de mod√©liser exactement notre m√©tier sans y incorporer de nombreux cas impossibles.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On note cependant depuis peu une √©mergence de langages au \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"type system\"},{\"type\":\"span\",\"value\":\" plus avanc√©, comme TypeScript (m√™me s'il est tr√®s facile de tricher dans ce langage), Swift, Kotlin et Rust. Et c'est √† mon sens une tr√®s bonne chose !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On voit qu'il est bien souvent possible d'inscrire dans nos types nos exigences et r√®gles m√©tiers. Le code s'en retrouve plus lisible et plus coh√©rent. Am√©liorer sa mod√©lisation permet d'am√©liorer la compr√©hension qu'on a de son code et diminue du m√™me coup la charge cognitive n√©cessaire pour le comprendre.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Chaque \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Maybe\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Either\"},{\"type\":\"span\",\"value\":\", par exemple, peut repr√©senter de l'incertitude. Et quand on commence √† mod√©liser son incertitude, on r√©alise rapidement que nos codebases en sont remplies. C'est √† ce moment pr√©cis qu'on peut alors chercher √† la r√©duire, en utilisant au maximum nos types.\"}]}]}},\"blocks\":[],\"links\":[{\"id1492635460\":\"51423405\",\"name12867311\":\"üá´üá∑  Des types au top\",\"slug12867311\":\"des-types-au-top\"}]},\"description12867311\":\"Apr√®s ce premier article sur les types, d√©couvrons maintenant les possibilit√©s plus avanc√©es d'un syst√®me de types : du type unitaire aux dependents types, tout en passant par les phantom types, voyons ensemble leurs avantages !\",\"bannerAttribution\":[]}}}"},"path":"blog/des-types-au-top-2"}