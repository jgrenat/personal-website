<!DOCTYPE html>
  <html lang="en">
  <head>
    <link rel="stylesheet" href="/style.css">
    
    <link rel="preload" href="/elm.js" as="script">
    <link rel="modulepreload" href="/index.js">
    
    <script defer="defer" src="/elm.js" type="text/javascript"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <script type="module">
import userInit from"/index.js";
let prefetchedPages=[window.location.pathname],initialLocationHash=document.location.hash.replace(/^#/,"");function loadContentAndInitializeApp(){let a=window.location.pathname.replace(/(w)$/,"$1/");a.endsWith("/")||(a+="/");const b=Elm.TemplateModulesBeta.init({flags:{secrets:null,baseUrl:document.baseURI,isPrerendering:!1,isDevServer:!1,isElmDebugMode:!1,contentJson:JSON.parse(document.getElementById("__ELM_PAGES_DATA__").innerHTML),userFlags:userInit.flags()}});return b.ports.toJsPort.subscribe(()=>{loadNamedAnchor()}),b}function loadNamedAnchor(){if(""!==initialLocationHash){const a=document.querySelector(`[name=${initialLocationHash}]`);a&&a.scrollIntoView()}}function prefetchIfNeeded(a){if(a.host===window.location.host&&!prefetchedPages.includes(a.pathname)){prefetchedPages.push(a.pathname),console.log("Preloading...",a.pathname);const b=document.createElement("link");b.setAttribute("as","fetch"),b.setAttribute("rel","prefetch"),b.setAttribute("href",origin+a.pathname+"/content.json"),document.head.appendChild(b)}}const appPromise=new Promise(function(a){document.addEventListener("DOMContentLoaded",()=>{a(loadContentAndInitializeApp())})});userInit.load(appPromise),"function"==typeof connect&&connect(function(a){appPromise.then(b=>{b.ports.fromJsPort.send({contentJson:a})})});const trigger_prefetch=b=>{const c=find_anchor(b.target);c&&c.href&&c.hasAttribute("elm-pages:prefetch")&&prefetchIfNeeded(c)};let mousemove_timeout;const handle_mousemove=a=>{clearTimeout(mousemove_timeout),mousemove_timeout=setTimeout(()=>{trigger_prefetch(a)},20)};addEventListener("touchstart",trigger_prefetch),addEventListener("mousemove",handle_mousemove);function find_anchor(a){for(;a&&"A"!==a.nodeName.toUpperCase();)a=a.parentNode;return a}
    </script>
    <title>ðŸ‡«ðŸ‡·  Des types au top - JoGrenat's Blog</title>
    <meta name="generator" content="elm-pages v2.1.9">
    <link rel="manifest" href="/manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <link rel="canonical" href="https://www.grenat.eu/blog/des-types-au-top" />    <meta name="description" content="Les types sont bien plus puissants que ce que peuvent nous laisser croire les types primitifs. Venez dÃ©couvrir avec moi les super pouvoirs des types !" />    <meta property="og:image" content="https://www.datocms-assets.com/53557/1628436466-types.jpg?fit=crop&max-h=250&max-w=800" />    <meta property="og:image:secure_url" content="https://www.datocms-assets.com/53557/1628436466-types.jpg?fit=crop&max-h=250&max-w=800" />    <meta property="og:image:alt" content="ðŸ‡«ðŸ‡·  Des types au top" />    <meta property="og:title" content="ðŸ‡«ðŸ‡·  Des types au top" />    <meta property="og:url" content="https://www.grenat.eu/blog/des-types-au-top" />    <meta property="og:description" content="Les types sont bien plus puissants que ce que peuvent nous laisser croire les types primitifs. Venez dÃ©couvrir avec moi les super pouvoirs des types !" />    <meta property="og:site_name" content="JoGrenat's Blog" />    <meta property="twitter:card" content="summary" />    <meta property="twitter:title" content="ðŸ‡«ðŸ‡·  Des types au top" />    <meta property="twitter:description" content="Les types sont bien plus puissants que ce que peuvent nous laisser croire les types primitifs. Venez dÃ©couvrir avec moi les super pouvoirs des types !" />    <meta property="twitter:image" content="https://www.datocms-assets.com/53557/1628436466-types.jpg?fit=crop&max-h=250&max-w=800" />    <meta property="twitter:image:alt" content="ðŸ‡«ðŸ‡·  Des types au top" />    <meta property="og:type" content="website" />    <link rel="sitemap" type="application/xml" href="/sitemap.xml" />    <link rel="icon" sizes="16x16" type="image/png" href="https://www.datocms-assets.com/53557/1629202623-favicon.png?h=16&w=16" />    <link rel="icon" sizes="32x32" type="image/png" href="https://www.datocms-assets.com/53557/1629202623-favicon.png?h=32&w=32" />    <link rel="icon" sizes="96x96" type="image/png" href="https://www.datocms-assets.com/53557/1629202623-favicon.png?h=96&w=96" />    <link rel="icon" sizes="192x192" type="image/png" href="https://www.datocms-assets.com/53557/1629202623-favicon.png?h=192&w=192" />
    <script id="__ELM_PAGES_DATA__" type="application/json">{"staticData":{"420756529":"{\"items\":[{\"id\":{\"videoId\":\"V2DgGyH6D_k\"}},{\"id\":{\"videoId\":\"Zp4p7DiWMuA\"}},{\"id\":{\"videoId\":\"WToGeMIdoSY\"}},{\"id\":{\"videoId\":\"AQkCgGajhxg\"}},{\"id\":{\"videoId\":\"uFzBmBoSrS0\"}}]}","1142833480":"{\"title\":\"[Code in the Unknown] Adding a \\\"cancel\\\" action to a chess game\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/Zp4p7DiWMuA/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/Zp4p7DiWMuA?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"[Code in the Unknown] Adding a &quot;cancel&quot; action to a chess game\\\"></iframe>\"}","2243736650":"{\"title\":\"Discovering Supabase, a Firebase alternative based on PostgreSQL (part 2)\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/V2DgGyH6D_k/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/V2DgGyH6D_k?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Discovering Supabase, a Firebase alternative based on PostgreSQL (part 2)\\\"></iframe>\"}","2730572102":"{\"title\":\"Creating a Elm package for DatoCMS (part 3)\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/uFzBmBoSrS0/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/uFzBmBoSrS0?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Creating a Elm package for DatoCMS (part 3)\\\"></iframe>\"}","2886442429":"{\"title\":\"Discovering Supabase, a Firebase alternative based on PostgreSQL\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/WToGeMIdoSY/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/WToGeMIdoSY?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Discovering Supabase, a Firebase alternative based on PostgreSQL\\\"></iframe>\"}","2986682595":"{\"title\":\"Creating a Elm package for DatoCMS (last part)\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/AQkCgGajhxg/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/AQkCgGajhxg?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Creating a Elm package for DatoCMS (last part)\\\"></iframe>\"}","3075083330":"{\"data\":{\"homePage\":{\"picture\":{\"url4062855192\":\"https://www.datocms-assets.com/53557/1630943458-profil-200.jpg?crop64=Zm9jYWxwb2ludCxmYWNlcyxlbnRyb3B5&fit=crop&h=80&mask=ellipse&w=80\"},\"introductionText12867311\":\"Passionate web developer, caring for user experience and code quality. In this blog, I share my discoveries and reflexions.\"},\"article3839572416\":{\"name1875757806\":\"\uD83C\uDDEB\uD83C\uDDF7  Des types au top\",\"banner\":{\"url1984142787\":\"https://www.datocms-assets.com/53557/1628436466-types.jpg?fit=crop&max-h=250&max-w=800\"},\"content103746919\":{\"value3343696236\":{\"schema\":\"dast\",\"document\":{\"type\":\"root\",\"children\":[{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Le commencement\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Ayant d\u00E9but\u00E9 avec PHP et JavaScript, j'ai longtemps cru que les types se limitaient en programmation \u00E0 ce que j'en voyais alors : une donn\u00E9e peut \u00EAtre un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"number\"},{\"type\":\"span\",\"value\":\", une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"string\"},{\"type\":\"span\",\"value\":\", un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"bool\"},{\"type\":\"span\",\"value\":\", une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"list\"},{\"type\":\"span\",\"value\":\" ou  un object. Toute donn\u00E9e dans mes programmes \u00E9tait une composition de ces diff\u00E9rents \u00E9l\u00E9ments.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Par exemple, la repr\u00E9sentation d'un dix de coeur dans un jeu de cartes pouvait \u00EAtre :\"}]},{\"code\":\"const tenOfHeart = { value: 10, color: 'hearts' };\",\"type\":\"code\",\"language\":\"javascript\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Mais alors comment repr\u00E9senter un valet de coeur ? Tout simplement en consid\u00E9rant qu'un valet vaut \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"11\"},{\"type\":\"span\",\"value\":\" !\"}]},{\"code\":\"const jackOfHeart = { value: 11, color: 'hearts' };\",\"type\":\"code\",\"language\":\"javascript\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Cela ne me choquait pas \u00E0 l'\u00E9poque. En regardant ce type de code aujourd'hui, deux consid\u00E9rations me viennent imm\u00E9diatement \u00E0 l'esprit. La premi\u00E8re est que ce mod\u00E8le va nous obliger \u00E0 avoir une traduction mentale de nos valeurs : partout o\u00F9 on veut repr\u00E9senter un valet, on doit se souvenir qu'il correspond au \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"11\"},{\"type\":\"span\",\"value\":\" , puis la dame au \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"12\"},{\"type\":\"span\",\"value\":\", etc. C'est un effort cognitif \u00E0 produire en plus et une chance de plus de commettre une erreur. Donc un bug !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"L'autre consid\u00E9ration est plus pr\u00E9occupante : si la dame vaut \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"12\"},{\"type\":\"span\",\"value\":\", le roi \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"13\"},{\"type\":\"span\",\"value\":\" et l'as \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"1\"},{\"type\":\"span\",\"value\":\", que valent ces cartes ?\"}]},{\"code\":\"const wtfOfHeart = { value: 199, color: 'hearts' };\\nconst what = { value: 2.6, color: 'hearts' };\\nconst areYouKidding = { value: NaN, color: 'green' };\",\"type\":\"code\",\"language\":\"javascript\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Et c'est l\u00E0 l'un des principaux probl\u00E8mes des types basiques : mis \u00E0 part le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"bool\"},{\"type\":\"span\",\"value\":\" qui peut avoir deux valeurs (\"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"true\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"false\"},{\"type\":\"span\",\"value\":\"), tous les autres types peuvent avoir virtuellement une infinit\u00E9 de valeurs possibles ! Or, il n'existe que 52 cartes dans le jeu classique qu'on souhaite repr\u00E9senter ! \"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Notre repr\u00E9sentation d'une carte peut donc avoir une infinit\u00E9 de valeurs possibles alors qu'on souhaite en g\u00E9rer 52 au maximum. Il s'ensuit qu'il existe une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"infinit\u00E9 - 52 = toujours une infinit\u00E9\"},{\"type\":\"span\",\"value\":\" de valeurs absurdes qui peuvent perturber l'ex\u00E9cution de notre programme ! Ce qui va nous obliger aux emplacements strat\u00E9giques \u00E0 effectuer des v\u00E9rifications \uD83D\uDE00\"}]},{\"code\":\"const validColors = ['hearts', 'spades', 'clubs', 'diamonds'];\\nfunction playCard(card) {\\n   if (card.value < 1 || card.value > 13 \\n      || !validColors.includes(card.colors)) {\\n      throw new Error('Invalid card!')\\n   }\\n   // ...\\n}\",\"type\":\"code\",\"language\":\"javascript\"},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Java \u00E0 la rescousse\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"J'ai plus tard appris Java, d\u00E9couvrant au passage les \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"enum\"},{\"type\":\"span\",\"value\":\"s. C'est une fa\u00E7on bien pratique de repr\u00E9senter un nombre fini de valeurs, ce qui nous donne au final \uD83D\uDE00\"}]},{\"code\":\"public enum Value {\\n   ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, \\n   EIGHT, NINE, TEN, JACK, QUEEN, KING;\\n}\\n\\npublic enum Color {\\n   HEARTS, CLUBS, SPADES, DIAMONDS;\\n}\\n\\npublic class Card {\\n   public Value value;\\n   public Color color;\\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Les choses s'am\u00E9liorent ! Si on regarde le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\", on se rend compte qu'il contient seulement 13 valeurs possibles et le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\" peut prendre 4 valeurs diff\u00E9rentes. Le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\" \u00E9tant compos\u00E9 d'une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\" et d'une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\", on peut donc repr\u00E9senter la combinaison des deux, c'est-\u00E0-dire \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"13 * 4 = 52\"},{\"type\":\"span\",\"value\":\" valeurs diff\u00E9rentes. Voyez comme les possibilit\u00E9s des types se \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"multiplient\"},{\"type\":\"span\",\"value\":\" quand on les combine !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Et \u00E7a tombe bien, notre jeu contient 52 cartes diff\u00E9rentes, on peut donc uniquement mod\u00E9liser des cartes valides ! Cela signifie qu'il n'est pas n\u00E9cessaire de v\u00E9rifier par la suite que notre carte est valide, comme c'\u00E9tait le cas avant. On gagne en s\u00E9curit\u00E9 dans notre code en ne permettant pas de repr\u00E9senter des \u00E9tats non coh\u00E9rents, que nous appellerons \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"\u00E9tats impossibles\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On gagne aussi en clart\u00E9 en lisant le code : plus besoin de faire un effort mental pour convertir \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"11\"},{\"type\":\"span\",\"value\":\" en \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Jack\"},{\"type\":\"span\",\"value\":\", puisque dans le code nous utilisons directement \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"JACK\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Le joker (pas celui de Joaquin Phoenix)\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Tout va bien jusqu'\u00E0 ce qu'on se rappelle un petit \u00E9l\u00E9ment d'importance : notre jeu de 52 cartes en contient en v\u00E9rit\u00E9 54, puisqu'il y a les deux jokers (le rouge et le noir). Et comme je veux jouer au \"},{\"url\":\"https://www.maison-facile.com/magazine/multimedia/se-divertir/jouer-entre-amis/188-jeux-de-cartes-le-8-americain/\",\"meta\":[{\"id\":\"target\",\"value\":\"_blank\"}],\"type\":\"link\",\"children\":[{\"type\":\"span\",\"value\":\"8 am\u00E9ricain\"}]},{\"type\":\"span\",\"value\":\", j'en ai besoin ! Modifions donc notre mod\u00E8le :\"}]},{\"code\":\"public enum Value {\\n   ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, \\n   EIGHT, NINE, TEN, JACK, QUEEN, KING, JOKER;\\n}\\n\\npublic enum Color {\\n   HEARTS, CLUBS, SPADES, DIAMONDS, RED, BLACK;\\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Avez-vous remarqu\u00E9 ce qu'il vient de se passer ? Notre type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\" contient maintenant \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"14\"},{\"type\":\"span\",\"value\":\" valeurs possibles, et le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\" en contient 6. Si on les combine, on se rend compte que notre type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\" peut repr\u00E9senter \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"14 * 6 = 84\"},{\"type\":\"span\",\"value\":\" valeurs ! On a donc 30 valeurs impossibles qui se sont gliss\u00E9s avec nos \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"52 + 2 = 54\"},{\"type\":\"span\",\"value\":\" valeurs possibles. Encore une fois, il faudra faire des v\u00E9rifications dans le code...\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Ou peut-\u00EAtre que non ?\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Les types alg\u00E9briques \"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Rappelez-vous : combiner deux valeurs dans un objet revient \u00E0 multiplier les cas possibles de chacune de ces valeurs :\"}]},{\"code\":\"public class Card {\\n   public Value value;\\n   public Color color;\\n}\\n// Value * Color = 13 * 4 = 52\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Le nombre de valeurs possibles d'un type s'appelle la \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"cardinalit\u00E9\"},{\"type\":\"span\",\"value\":\". Ici, la cardinalit\u00E9 du type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\" est 13 (= il peut avoir 13 valeurs diff\u00E9rentes), celle du type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\" est 4 et celle du type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\" est 52.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Pour obtenir 54 valeurs possibles et repr\u00E9senter nos deux jokers, on aimerait id\u00E9alement pouvoir avoir une cardinalit\u00E9 de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"52 + 2 = 54\"},{\"type\":\"span\",\"value\":\". Or, nous savons uniquement \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"multipler\"},{\"type\":\"span\",\"value\":\" les cardinalit\u00E9s des types, pas les additionner ! Vraiment ? Ce n'est pas si s\u00FBr !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Si on ajoutait simplement une nouvelle couleur, notre type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\" deviendrait ainsi :\"}]},{\"code\":\"public enum Color {\\n   HEARTS, CLUBS, SPADES, DIAMONDS, NEW_COLOR;\\n}\",\"type\":\"code\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Sa cardinalit\u00E9 devient donc \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"4 + 1 = 5\"},{\"type\":\"span\",\"value\":\". Eh oui, ajouter 1 membre \u00E0 un enum \u00E9quivaut \u00E0 ajouter 1 \u00E0 sa cardinalit\u00E9 !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Prenons maintenant un peu de recul. Pour d\u00E9crire le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\" en bon franglais, on pourrait dire ceci :\"}]},{\"type\":\"blockquote\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\" est un type qui peut valoir \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"HEARTS\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"CLUBS\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"SPADES\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"DIAMONDS\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"NEW_COLOR\"},{\"type\":\"span\",\"value\":\".\"}]}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"A l'inverse, on constate que notre type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\" serait plut\u00F4t d\u00E9crit de la fa\u00E7on suivante :\"}]},{\"type\":\"blockquote\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\" est un type compos\u00E9 d'une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"et\"},{\"type\":\"span\",\"value\":\" d'une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\".\"}]}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Intuitivement, on comprend donc qu'un \\\"\"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\"\\\" revient \u00E0 \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"additionner\"},{\"type\":\"span\",\"value\":\" les cardinalit\u00E9s, alors qu'un \\\"\"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"et\"},{\"type\":\"span\",\"value\":\"\\\" revient \u00E0 \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"multipler\"},{\"type\":\"span\",\"value\":\" les cardinalit\u00E9s !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Mais alors comment d\u00E9crire  notre type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\" contenant les deux jokers ? Voil\u00E0 ce que je propose :\"}]},{\"type\":\"blockquote\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Card est un type qui peut valoir \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"BLACK_JOKER\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"RED_JOKER\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" \u00EAtre compos\u00E9 d'une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"et\"},{\"type\":\"span\",\"value\":\" d'une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\".\"}]}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On voit donc qu'on souhaite \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"additionner\"},{\"type\":\"span\",\"value\":\" trois \u00E9l\u00E9ments diff\u00E9rents, dont le dernier est une \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"multiplication\"},{\"type\":\"span\",\"value\":\" de deux \u00E9l\u00E9ments. Quelque chose comme \u00E7a :\"}]},{\"code\":\"public enum Card {\\n   BLACK_JOKER, RED_JOKER, SIMPLE_CARD(Value, Color);\\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Sauf qu'\u00E9videmment, cette syntaxe n'est pas du Java valide ! Il s'agit d'un \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"type alg\u00E9brique\"},{\"type\":\"span\",\"value\":\", c'est-\u00E0-dire un type compos\u00E9 d'autres types, soit en les additionnant (on parle alors de \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"types somme ou sum type\"},{\"type\":\"span\",\"value\":\"), soit en les multipliant (on parle alors de \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"\\u001dtypes produit ou product type\"},{\"type\":\"span\",\"value\":\"). \"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Ils ne sont malheureusement pas support\u00E9s dans tous les langages. Voil\u00E0 comment on pourrait le repr\u00E9senter en [Elm, un langage front-end compilant en JavaScript](./ce-que-jaime-en-elm) :\"}]},{\"code\":\"type Card =\\n   BlackJoker \\n   | RedJoker\\n   | SimpleCard Value Color\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On peut ensuite utiliser ce type :\"}]},{\"code\":\"myBlackJoker = BlackJoker\\nmyTenOfClubs = SimpleCard Ten Clubs\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Il n'est ainsi plus possible de repr\u00E9senter de valeurs impossibles dans notre programme ! La cardinalit\u00E9 de notre repr\u00E9sentation est \u00E9gale \u00E0 la cardinalit\u00E9 du probl\u00E8me m\u00E9tier qu'on souhaite repr\u00E9senter. On peut donc \u00E9viter partout dans le code des v\u00E9rifications manuelles : si on poss\u00E8de une valeur de type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\", celle-ci est forc\u00E9ment valide. C'est toute une cat\u00E9gorie de bugs \u00E9vit\u00E9e !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Les langages supportant les \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"types alg\u00E9briques\"},{\"type\":\"span\",\"value\":\" sont par exemple Rust, Haskell, Scala, OCaml, Elm, ReasonML, etc. Ce sont surtout des langages fonctionnels. Certains les utilisent plus ou moins en \"},{\"url\":\"https://proandroiddev.com/algebraic-data-types-in-kotlin-337f22ef230a\",\"meta\":[{\"id\":\"target\",\"value\":\"_blank\"}],\"type\":\"link\",\"children\":[{\"type\":\"span\",\"value\":\"Kotlin\"}]},{\"type\":\"span\",\"value\":\" \u00E9galement.\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"J'ai menti...\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Il faut que je fasse un aveu : je vous ai menti dans les premi\u00E8res parties de cet article. Plus exactement en parlant du code suivant :\"}]},{\"code\":\"public enum Value {\\n   ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, \\n   EIGHT, NINE, TEN, JACK, QUEEN, KING;\\n}\\n\\npublic enum Color {\\n   HEARTS, CLUBS, SPADES, DIAMONDS;\\n}\\n\\npublic class Card {\\n   public Value value;\\n   public Color color;\\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Je vous ai affirm\u00E9 que la cardinalit\u00E9 du type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\" \u00E9tait de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"13 * 4 = 52\"},{\"type\":\"span\",\"value\":\", mais ce n'est pas le cas. En effet, nous sommes en Java et il faut donc compter avec la possibilit\u00E9 que les valeurs soient \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\". On a donc 5 valeurs possibles pour la \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\" (\"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"HEARTS\"},{\"type\":\"span\",\"value\":\", \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"CLUBS\"},{\"type\":\"span\",\"value\":\", \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"SPADES\"},{\"type\":\"span\",\"value\":\", \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"DIAMONDS\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\") et 14 valeurs possibles pour la \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\", ce qui nous fait une cardinalit\u00E9 de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"14 * 5 = 70\"},{\"type\":\"span\",\"value\":\", bien au-del\u00E0 de la cardinalit\u00E9 qu'on cherchait \u00E0 repr\u00E9senter !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\" est cens\u00E9 repr\u00E9senter une valeur qui n'est pas pr\u00E9sente, souvent parce qu'elle n'a pas \u00E9t\u00E9 initialis\u00E9e. Mais cette valeur est un peu magique : \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\" peut \u00EAtre de n'importe quel type et on doit donc le compter dans toutes nos cardinalit\u00E9s. \"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Beaucoup d'exceptions et de bugs sont dus \u00E0 ces valeurs \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null \"},{\"type\":\"span\",\"value\":\"en Java, parce que le d\u00E9veloppeur oublie de les g\u00E9rer. En JavaScript, c'est m\u00EAme pire, puisqu'on a \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"undefined\"},{\"type\":\"span\",\"value\":\"` \u00E0 prendre en compte ! A tel point que des langages ont d\u00E9cid\u00E9 de ne pas avoir cette \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"valeur joker\"},{\"type\":\"span\",\"value\":\" dans le langage. \"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Mais alors comment repr\u00E9senter une valeur qui peut \u00EAtre d\u00E9finie ou non ? Essayons en toutes lettres de d\u00E9finir une chaine de caract\u00E8res qui peut ne pas \u00EAtre d\u00E9finie :\"}]},{\"type\":\"blockquote\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"C'est une valeur qui peut valoir \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" contenir une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"String\"}]}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Est-ce que \u00E7a ne ressemble pas \u00E0 un \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"type somme\"},{\"type\":\"span\",\"value\":\" ? Et effectivement, c'est comme \u00E7a que ces langages le d\u00E9finissent, petit exemple en Elm :\"}]},{\"code\":\"type MaybeString = \\n   Nothing\\n   | Just String\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On voit que la valeur est soit \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Nothing\"},{\"type\":\"span\",\"value\":\", soit un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Just\"},{\"type\":\"span\",\"value\":\" contenant notre chaine de caract\u00E8res. Et \u00E7a fait toute la diff\u00E9rence avec le \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\" de Java : partout o\u00F9 une valeur peut ne pas \u00EAtre d\u00E9finie, le d\u00E9veloppeur doit l'indiquer dans son type (en utilisant \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"MaybeString\"},{\"type\":\"span\",\"value\":\" au lieu de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"String\"},{\"type\":\"span\",\"value\":\" par exemple). Comme c'est \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"explicite\"},{\"type\":\"span\",\"value\":\", le compilateur peut donc vous forcer \u00E0 g\u00E9rer le cas, \u00E9vitant un bug d\u00FB \u00E0 l'inattention d'un d\u00E9veloppeur !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"J'ai menti une seconde fois : le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"MaybeString\"},{\"type\":\"span\",\"value\":\" n'existe pas en Elm. Il s'agit en fait d'un type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Maybe\"},{\"type\":\"span\",\"value\":\" g\u00E9n\u00E9rique qui prend en argument un type (\"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"a\"},{\"type\":\"span\",\"value\":\" dans l'exemple ci-dessous) pour retourner un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Maybe a\"},{\"type\":\"span\",\"value\":\". Cela \u00E9vite de red\u00E9finir un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"MaybeInt\"},{\"type\":\"span\",\"value\":\", un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"MaybeString\"},{\"type\":\"span\",\"value\":\", un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"MaybeCard\"},{\"type\":\"span\",\"value\":\"... Voyez le \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"a\"},{\"type\":\"span\",\"value\":\" comme une variable repr\u00E9sentant un type.\"}]},{\"code\":\"type Maybe a =\\n   Nothing\\n   | Just a\\n\\nmyCard : Maybe Card -- indique le type de myCard\\nmyCard = Just RedJoker\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"C'est fini, plus de mensonges entre nous !\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Des applications d'exception\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"La grande force des types alg\u00E9briques, c'est qu'ils vous donnent les moyens de mod\u00E9liser votre mod\u00E8le de fa\u00E7on beaucoup plus pr\u00E9cise ! Nous l'avons vu pour le cas des valeurs qui peuvent \u00EAtre non d\u00E9finies, mais les applications sont tr\u00E8s nombreuses.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Par exemple, prenons une op\u00E9ration qui peut \u00E9chouer : nous essayons de lire le contenu d'un fichier. Cette requ\u00EAte peut \u00E9chouer de diff\u00E9rentes mani\u00E8res : le fichier n'existe pas, le programme n'a pas les droits en lecture, le fichier est bloqu\u00E9 par une autre ressource, .... Dans certains langages, la fa\u00E7on de g\u00E9rer ces erreurs est toute trouv\u00E9e : les \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"exceptions\"},{\"type\":\"span\",\"value\":\". En Java notamment, il faut \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"penser\"},{\"type\":\"span\",\"value\":\" \u00E0 g\u00E9rer ces exceptions avec un bloc \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"try...catch\"},{\"type\":\"span\",\"value\":\" :\"}]},{\"code\":\"try {\\n   Files.readAllLines(filePath, UTF_8);`\\n} catch (IOException e) {\\n   // gestion de l'erreur\\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"C'est ici acceptable parce que le compilateur force l'utilisateur \u00E0 g\u00E9rer cette \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"IOException\"},{\"type\":\"span\",\"value\":\" explicitement, soit avec ce bloc \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"try...catch\"},{\"type\":\"span\",\"value\":\", soit en indiquant dans la d\u00E9finition de la fonction que celle-ci peut renvoyer une exception. Cependant, en lisant \"},{\"url\":\"https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines(java.nio.file.Path,%20java.nio.charset.Charset%29\",\"meta\":[{\"id\":\"target\",\"value\":\"_blank\"}],\"type\":\"link\",\"children\":[{\"type\":\"span\",\"value\":\"la documentation de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Files.readAllLines\"}]},{\"type\":\"span\",\"value\":\", on se rend compte qu'il existe un second type d'exception, \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"SecurityException\"},{\"type\":\"span\",\"value\":\" qui est une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"RuntimeException\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Pour ceux qui ne font pas de Java, cela veut dire que le d\u00E9veloppeur n'est pas \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"oblig\u00E9\"},{\"type\":\"span\",\"value\":\" de g\u00E9rer cette erreur. Et j'irai m\u00EAme plus loin : rien n'est fait pour que le d\u00E9veloppeur ait \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"conscience\"},{\"type\":\"span\",\"value\":\" que cette erreur peut se produire ! Il est d\u00E8s lors possible que ces erreurs se manifestent en production.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Une exception va remonter la pile d'appels jusqu'\u00E0 ce qu'elle soit attrap\u00E9e par un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"try...catch\"},{\"type\":\"span\",\"value\":\" ou remonter jusqu'\u00E0 l'utilisateur le cas \u00E9ch\u00E9ant. Dans de plus en plus de langages, on a tendance \u00E0 ne plus utiliser d'exceptions \u00E0 cause de ce c\u00F4t\u00E9 \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"magique\"},{\"type\":\"span\",\"value\":\" et implicite. Pour rendre cela explicite, on fait porter cette information par le type de retour de notre fonction, comme on pouvait le faire plus haut avec un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Maybe String\"},{\"type\":\"span\",\"value\":\" pour une valeur pouvant \u00EAtre non d\u00E9finie.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"En Rust par exemple, il existe un type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result\"},{\"type\":\"span\",\"value\":\" :\"}]},{\"code\":\"enum Result<T, E> {\\n   Ok(T),\\n   Err(E),\\n}\",\"type\":\"code\",\"language\":\"rust\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"T\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"E\"},{\"type\":\"span\",\"value\":\" sont des variables de types, cela signifie donc que notre valeur de type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result\"},{\"type\":\"span\",\"value\":\" est soit un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Ok\"},{\"type\":\"span\",\"value\":\" contenant une valeur de type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"T\"},{\"type\":\"span\",\"value\":\", soit un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Err\"},{\"type\":\"span\",\"value\":\" de  type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"E\"},{\"type\":\"span\",\"value\":\". D\u00E8s lors, le d\u00E9veloppeur est oblig\u00E9 d'extraire cette valeur et donc de consid\u00E9rer et g\u00E9rer le cas d'erreur de fa\u00E7on explicite.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"La signature de la fonction \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"read\"},{\"type\":\"span\",\"value\":\" en Rust est du coup la suivante :\"}]},{\"code\":\"fn read(&mut self, buf: &mut [u8]) -> Result<usize, io::Error>\",\"type\":\"code\",\"language\":\"rust\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"La seule partie importante pour nous est le retour : on re\u00E7oit un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result\"},{\"type\":\"span\",\"value\":\" qui, en cas de succ\u00E8s va \u00EAtre un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Ok\"},{\"type\":\"span\",\"value\":\" contenant un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"usize\"},{\"type\":\"span\",\"value\":\" (un pointeur en m\u00E9moire vers le r\u00E9sultat) et en cas d'\u00E9chec va \u00EAtre un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Err\"},{\"type\":\"span\",\"value\":\" contenant la cause de l'erreur de type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"io::Error\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On voit ici qu'en plus de s\u00E9curiser le d\u00E9veloppement de l'application en for\u00E7ant le d\u00E9veloppeur \u00E0 g\u00E9rer les cas d'erreur, le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result\"},{\"type\":\"span\",\"value\":\" joue le r\u00F4le de \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"documentation\"},{\"type\":\"span\",\"value\":\" du code : on \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"sait\"},{\"type\":\"span\",\"value\":\" que cette m\u00E9thode peut \u00E9chouer en lisant la signature.\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Je perds la \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"bool\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Mais pas besoin d'avoir des \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"types alg\u00E9briques\"},{\"type\":\"span\",\"value\":\" pour am\u00E9liorer son code gr\u00E2ce aux types, on peut d\u00E9j\u00E0 aller loin avec des \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"enum\"},{\"type\":\"span\",\"value\":\"s. Regardons cette fonction en Java, permettant de commander un produit en ligne :\"}]},{\"code\":\"public Order orderProduct(Product product, boolean withGiftWrap) {\\n   // ...\\n}\\n\\norderProduct(book, true);\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On peut remarquer deux choses : la fonction retourne un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Order\"},{\"type\":\"span\",\"value\":\", alors que d'exp\u00E9rience, ce genre de m\u00E9thode peut s\u00FBrement \u00E9chouer pour de nombreuses raisons diff\u00E9rentes. Cela signifie que cette m\u00E9thode a de grandes chances de lancer des exceptions en cas d'erreur ! Mais passons, c'est le second point qui nous int\u00E9resse ici : si on ne voit que l'appel de la fonction, on peut se demander ce que signifie ce \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"true\"},{\"type\":\"span\",\"value\":\" pass\u00E9 en second argument.  La seule fa\u00E7on de le savoir est d'aller voir la d\u00E9finition de la fonction pour constater qu'il s'agit de l'ajout ou non de papier cadeau. On appelle cela \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"boolean blindness\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Souvent, les bool\u00E9ens sont utilis\u00E9s par facilit\u00E9, alors que l'utilisation d'un enum am\u00E9liorerait de beaucoup la lisibilit\u00E9 :\"}]},{\"code\":\"public enum GiftWrap {\\n   NO_GIFT_WRAP, WITH_GIFT_WRAP;\\n}\\n\\npublic Order orderProduct(Product product, GiftWrap giftWrap) {\\n   // ...\\n}\\n\\norderProduct(book, WITH_GIFT_WRAP);\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"N'est-ce pas plus lisible ? Et surtout cela nous permettra d'\u00E9voluer plus facilement : si demain on souhaite laisser le choix entre deux types de papier cadeaux, on peut juste rajouter des \u00E9l\u00E9ments \u00E0 l'enum.\"}]},{\"code\":\"public enum GiftWrap {\\n   NO_GIFT_WRAP, CHILD_GIFT_WRAP, ADULT_GIFT_WRAP;\\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"A chaque fois qu'on se retrouve \u00E0 utiliser des bool\u00E9ens, il faut se demander si notre intention ne serait pas plus clair avec un enum explicitant vraiment la valeur m\u00E9tier.\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"L'appliquer d\u00E8s aujourd'hui\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Si vous avez l'occasion d'utiliser un langage avec des types alg\u00E9briques qui correspond \u00E0 votre probl\u00E8me, foncez ! Ce n'est cependant pas toujours le cas, et bien qu'il soit possible d'\u00E9muler leur fonctionnement dans certains langages, la cr\u00E9ation est souvent peu pratique.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Cependant, on trouve dans tous les langages des biblioth\u00E8ques d'utilitaires fournissant des \u00E9l\u00E9ments comme le \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Maybe\"},{\"type\":\"span\",\"value\":\" (parfois appel\u00E9 \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Option\"},{\"type\":\"span\",\"value\":\" ou \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Optional\"},{\"type\":\"span\",\"value\":\") et le \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result\"},{\"type\":\"span\",\"value\":\" (parfois appel\u00E9 \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Either\"},{\"type\":\"span\",\"value\":\",  \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Try\"},{\"type\":\"span\",\"value\":\" s'il est  sp\u00E9cialis\u00E9 pour des exceptions). C'est le cas en Java notamment avec \"},{\"url\":\"https://www.vavr.io/\",\"meta\":[{\"id\":\"target\",\"value\":\"_blank\"}],\"type\":\"link\",\"children\":[{\"type\":\"span\",\"value\":\"l'excellente biblioth\u00E8que Vavr\"}]},{\"type\":\"span\",\"value\":\". En TypeScript, vous pouvez \u00E9galement activer l'option \"},{\"url\":\"https://basarat.gitbooks.io/typescript/docs/options/strictNullChecks.html\",\"meta\":[{\"id\":\"target\",\"value\":\"_blank\"}],\"type\":\"link\",\"children\":[{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"strictNullChecks\"}]},{\"type\":\"span\",\"value\":\" qui ajoute plus de v\u00E9rifications sur les \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"undefined\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Dans tous les cas, mon premier conseil est le suivant : d\u00E9barrassez-vous de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\". Rendez  l'absence de valeur explicite et vous \u00E9viterez beaucoup de probl\u00E8mes. Faites de m\u00EAme avec les exceptions.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Mon second conseil est d'\u00E9viter au maximum la \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"primitive obsession\"},{\"type\":\"span\",\"value\":\" : n'h\u00E9sitez pas \u00E0 cr\u00E9er des objets / enums plut\u00F4t que d'utiliser les types primitifs comme \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"string\"},{\"type\":\"span\",\"value\":\", \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"bool\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"number\"},{\"type\":\"span\",\"value\":\". Il me semble avoir vu un jour cette citation dont je ne connais ni l'origine ni l'auteur et que j'ai peut-\u00EAtre involontairement d\u00E9form\u00E9e (n'h\u00E9sitez pas \u00E0 m'envoyer la r\u00E9f\u00E9rence si vous l'avez) :\"}]},{\"type\":\"blockquote\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Quand vous \u00E9crivez qu'une fonction prend un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"string\"},{\"type\":\"span\",\"value\":\" en argument, votre fonction \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"doit\"},{\"type\":\"span\",\"value\":\" accepter l'int\u00E9gralit\u00E9 des oeuvres de Shakespeare en mandarin en param\u00E8tre.\"}]}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Et mon dernier conseil est sans doute le plus important : essayez de rendre possible uniquement les valeurs que votre m\u00E9tier accepte ; \u00E9liminez gr\u00E2ce aux types le maximum d'\u00E9tats impossibles. En ce sens, je vous recommande cet excellent talk de Richard Feldman (en anglais) : \"},{\"url\":\"https://www.youtube.com/watch?v=IcgmSRJHu_8\",\"meta\":[{\"id\":\"target\",\"value\":\"_blank\"}],\"type\":\"link\",\"children\":[{\"type\":\"span\",\"value\":\"Making impossible states impossible\"}]},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"Cet article poss\u00E8de une seconde partie, \"},{\"item\":\"51975991\",\"type\":\"itemLink\",\"children\":[{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"cliquez ici pour lire la suite\"}]},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\".\"}]}]}},\"blocks\":[],\"links\":[{\"id1492635460\":\"51975991\",\"name12867311\":\"\uD83C\uDDEB\uD83C\uDDF7   Des types au top (2)\",\"slug12867311\":\"des-types-au-top-2\"}]},\"description12867311\":\"Les types sont bien plus puissants que ce que peuvent nous laisser croire les types primitifs. Venez d\u00E9couvrir avec moi les super pouvoirs des types !\",\"bannerAttribution\":[]}}}","3644372390":"{\"data\":{\"websiteConfiguration\":{\"name12867311\":\"JoGrenat's Blog\",\"youtubeChannelId12867311\":\"UCROJRWWGrrTmgGF1Wo9OX5w\",\"twitterIcon\":{\"url3832528868\":\"https://www.datocms-assets.com/53557/1632324226-twitterbird.svg\"},\"footerText12867311\":\"*Blog powered by [elm-pages](https://elm-pages.com/)*\"},\"_site\":{\"globalSeo\":{\"fallbackSeo\":{\"image\":{\"url1831060520\":\"https://www.datocms-assets.com/53557/1632838280-capture-d-ecran-2021-09-28-a-16-11-09.png?fit=fill&max-h=150&max-w=300\"}}}}}}"},"is404":false,"path":"blog/des-types-au-top"}</script>
    </head>
    <body>
      <div data-url="" display="none"></div>
      <div><span class="elm-css-style-wrapper" style="display: none;"><style></style></span><span class="elm-css-style-wrapper" style="display: none;"><style>.footer{padding-top:0;padding-bottom:0;font-size:1rem;}
.footerContent{margin:1rem 0;}
.footerContent  h2{font-size:2.2rem;font-weight:900;text-align:left;margin:3.5rem 0 1rem;}
.footerContent  h3{font-size:1.8rem;font-weight:600;text-align:left;margin:3vh 0 1vh;color:rgba(0,0,0,0.8);}
.footerContent  h4{font-size:1.2rem;font-weight:200;text-align:left;margin:2vh 0 1vh;color:rgba(0,0,0,0.6);}
.footerContent  p{margin:2.5rem 0;line-height:2rem;white-space:pre-wrap;text-align:justify;color:rgba(0,0,0,0.8);}
.footerContent  p > code{background-color:rgba(225,225,255,0.7);padding:1px 3px;font-size:0.7em;}
.footerContent  blockquote{border-left:5px solid rgba(5,117,230,0.8);background-color:rgba(5,117,230,0.1);padding:0.01vh 1vw;max-width:650px;margin:2.5rem auto;}
@media only screen and (max-width: 600px){.footerContent  blockquote{border-left:0;border-top:5px solid rgba(5,117,230,0.8);padding:0.01vh 3vw;}}
.footerContent  blockquote > p:first-child{margin-top:1rem;}
.footerContent  blockquote > p:last-child{margin-bottom:1rem;}
.footerContent  strong{font-weight:900;color:rgb(0,0,0);}
.footerContent  em{font-style:italic;}
.footerContent  a{text-decoration:underline;}
.footerContent  a:hover{text-decoration:none;}
.footerContent  .thanks{margin-top:2vw;font-style:italic;font-size:0.8em;text-align:right;}
.footerContent  ul{list-style-type:disc;padding-left:1rem;margin-left:2vh;}
.footerContent  ul > li + li{margin-top:2vh;}
.footerContent  pre{max-width:100%;overflow-y:scroll;}
.footerContent  code{line-height:1.7rem;font-size:0.85em;}
.footerContent  img{max-width:100%;}
.footerContent  img.fullWidth{width:100%;}
.footerContent > :first-child{margin-top:0;}
.footerContent > :last-child{margin-bottom:0;}
.footerContent  p{text-align:right;}</style></span><main class="container"><span class="elm-css-style-wrapper" style="display: none;"><style>.site-title{display:flex;justify-content:space-between;align-items:center;font-size:1.5rem;margin:0.5rem 0 2rem;}
.site-title  a{text-decoration:none;}
.site-title  img{width:2rem;transition:transform 100ms  ;}
.site-title  img:hover{transform:scale(1.5);}
.site-title  .site-name{transition:transform 100ms  ;transform-origin:center left;}
.site-title  .site-name:hover{transform:scale(1.1);}
.article{margin-top:20px;}
.article  .article-title{font-size:3rem;text-align:center;margin-bottom:3rem;font-weight:900;}
.article  .article-banner{width:100%;padding-top:31.25%;position:relative;}
.article  .article-banner.article-banner--withAttribution{margin-bottom:4rem;}
.article  .article-banner.article-banner--withAttribution  figcaption{position:absolute;top:103%;left:0;width:100%;text-align:center;font-size:0.8rem;color:rgba(0,0,0,0.7);}
.article  .article-banner.article-banner--withAttribution  figcaption  em{font-style:italic;}
.article  .article-banner  img{position:absolute;top:0;left:0;width:100%;height:100%;}
.article  .article-content{margin-bottom:5vh;}
.article  .article-content  h2{font-size:2.2rem;font-weight:900;text-align:left;margin:3.5rem 0 1rem;}
.article  .article-content  h3{font-size:1.8rem;font-weight:600;text-align:left;margin:3vh 0 1vh;color:rgba(0,0,0,0.8);}
.article  .article-content  h4{font-size:1.2rem;font-weight:200;text-align:left;margin:2vh 0 1vh;color:rgba(0,0,0,0.6);}
.article  .article-content  p{margin:2.5rem 0;line-height:2rem;white-space:pre-wrap;text-align:justify;color:rgba(0,0,0,0.8);}
.article  .article-content  p > code{background-color:rgba(225,225,255,0.7);padding:1px 3px;font-size:0.7em;}
.article  .article-content  blockquote{border-left:5px solid rgba(5,117,230,0.8);background-color:rgba(5,117,230,0.1);padding:0.01vh 1vw;max-width:650px;margin:2.5rem auto;}
@media only screen and (max-width: 600px){.article  .article-content  blockquote{border-left:0;border-top:5px solid rgba(5,117,230,0.8);padding:0.01vh 3vw;}}
.article  .article-content  blockquote > p:first-child{margin-top:1rem;}
.article  .article-content  blockquote > p:last-child{margin-bottom:1rem;}
.article  .article-content  strong{font-weight:900;color:rgb(0,0,0);}
.article  .article-content  em{font-style:italic;}
.article  .article-content  a{text-decoration:underline;}
.article  .article-content  a:hover{text-decoration:none;}
.article  .article-content  .thanks{margin-top:2vw;font-style:italic;font-size:0.8em;text-align:right;}
.article  .article-content  ul{list-style-type:disc;padding-left:1rem;margin-left:2vh;}
.article  .article-content  ul > li + li{margin-top:2vh;}
.article  .article-content  pre{max-width:100%;overflow-y:scroll;}
.article  .article-content  code{line-height:1.7rem;font-size:0.85em;}
.article  .article-content  img{max-width:100%;}
.article  .article-content  img.fullWidth{width:100%;}
.author-card{display:flex;align-items:center;margin-top:2.5rem;}
.author-card > .author-picture{margin-right:1rem;}
.author-card > .author-description{text-align:justify;font-size:1rem;line-height:1.5rem;}</style></span><div class="site-title"><a class="site-name" elm-pages:prefetch="" href="/">JoGrenat&#039;s Blog</a><a href="https://twitter.com/JoGrenat"><img src="https://www.datocms-assets.com/53557/1632324226-twitterbird.svg"></a></div><section class="article"><h1 class="article-title">ðŸ‡«ðŸ‡·  Des types au top</h1><figure class="article-banner " aria-hidden="true"><img alt="" src="https://www.datocms-assets.com/53557/1628436466-types.jpg?fit=crop&max-h=250&max-w=800"></figure><div class="article-content"><div><h2>Le commencement</h2><p>Ayant dÃ©butÃ© avec PHP et JavaScript, j&#039;ai longtemps cru que les types se limitaient en programmation Ã  ce que j&#039;en voyais alors : une donnÃ©e peut Ãªtre un <code>number</code>, une <code>string</code>, un <code>bool</code>, une <code>list</code> ou  un object. Toute donnÃ©e dans mes programmes Ã©tait une composition de ces diffÃ©rents Ã©lÃ©ments.</p><p>Par exemple, la reprÃ©sentation d&#039;un dix de coeur dans un jeu de cartes pouvait Ãªtre :</p><pre><code class="lang-javascript">const tenOfHeart = { value: 10, color: &#039;hearts&#039; };</code></pre><p>Mais alors comment reprÃ©senter un valet de coeur ? Tout simplement en considÃ©rant qu&#039;un valet vaut <code>11</code> !</p><pre><code class="lang-javascript">const jackOfHeart = { value: 11, color: &#039;hearts&#039; };</code></pre><p>Cela ne me choquait pas Ã  l&#039;Ã©poque. En regardant ce type de code aujourd&#039;hui, deux considÃ©rations me viennent immÃ©diatement Ã  l&#039;esprit. La premiÃ¨re est que ce modÃ¨le va nous obliger Ã  avoir une traduction mentale de nos valeurs : partout oÃ¹ on veut reprÃ©senter un valet, on doit se souvenir qu&#039;il correspond au <code>11</code> , puis la dame au <code>12</code>, etc. C&#039;est un effort cognitif Ã  produire en plus et une chance de plus de commettre une erreur. Donc un bug !</p><p>L&#039;autre considÃ©ration est plus prÃ©occupante : si la dame vaut <code>12</code>, le roi <code>13</code> et l&#039;as <code>1</code>, que valent ces cartes ?</p><pre><code class="lang-javascript">const wtfOfHeart = { value: 199, color: &#039;hearts&#039; };
const what = { value: 2.6, color: &#039;hearts&#039; };
const areYouKidding = { value: NaN, color: &#039;green&#039; };</code></pre><p>Et c&#039;est lÃ  l&#039;un des principaux problÃ¨mes des types basiques : mis Ã  part le type <code>bool</code> qui peut avoir deux valeurs (<code>true</code> et <code>false</code>), tous les autres types peuvent avoir virtuellement une infinitÃ© de valeurs possibles ! Or, il n&#039;existe que 52 cartes dans le jeu classique qu&#039;on souhaite reprÃ©senter ! </p><p>Notre reprÃ©sentation d&#039;une carte peut donc avoir une infinitÃ© de valeurs possibles alors qu&#039;on souhaite en gÃ©rer 52 au maximum. Il s&#039;ensuit qu&#039;il existe une <code>infinitÃ© - 52 = toujours une infinitÃ©</code> de valeurs absurdes qui peuvent perturber l&#039;exÃ©cution de notre programme ! Ce qui va nous obliger aux emplacements stratÃ©giques Ã  effectuer des vÃ©rifications ðŸ˜€</p><pre><code class="lang-javascript">const validColors = [&#039;hearts&#039;, &#039;spades&#039;, &#039;clubs&#039;, &#039;diamonds&#039;];
function playCard(card) {
   if (card.value &lt; 1 || card.value &gt; 13 
      || !validColors.includes(card.colors)) {
      throw new Error(&#039;Invalid card!&#039;)
   }
   // ...
}</code></pre><h2>Java Ã  la rescousse</h2><p>J&#039;ai plus tard appris Java, dÃ©couvrant au passage les <code>enum</code>s. C&#039;est une faÃ§on bien pratique de reprÃ©senter un nombre fini de valeurs, ce qui nous donne au final ðŸ˜€</p><pre><code class="lang-java">public enum Value {
   ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, 
   EIGHT, NINE, TEN, JACK, QUEEN, KING;
}

public enum Color {
   HEARTS, CLUBS, SPADES, DIAMONDS;
}

public class Card {
   public Value value;
   public Color color;
}</code></pre><p>Les choses s&#039;amÃ©liorent ! Si on regarde le type <code>Value</code>, on se rend compte qu&#039;il contient seulement 13 valeurs possibles et le type <code>Color</code> peut prendre 4 valeurs diffÃ©rentes. Le type <code>Card</code> Ã©tant composÃ© d&#039;une <code>Value</code> et d&#039;une <code>Color</code>, on peut donc reprÃ©senter la combinaison des deux, c&#039;est-Ã -dire <code>13 * 4 = 52</code> valeurs diffÃ©rentes. Voyez comme les possibilitÃ©s des types se <em>multiplient</em> quand on les combine !</p><p>Et Ã§a tombe bien, notre jeu contient 52 cartes diffÃ©rentes, on peut donc uniquement modÃ©liser des cartes valides ! Cela signifie qu&#039;il n&#039;est pas nÃ©cessaire de vÃ©rifier par la suite que notre carte est valide, comme c&#039;Ã©tait le cas avant. On gagne en sÃ©curitÃ© dans notre code en ne permettant pas de reprÃ©senter des Ã©tats non cohÃ©rents, que nous appellerons <strong>Ã©tats impossibles</strong>.</p><p>On gagne aussi en clartÃ© en lisant le code : plus besoin de faire un effort mental pour convertir <code>11</code> en <code>Jack</code>, puisque dans le code nous utilisons directement <code>JACK</code>.</p><h2>Le joker (pas celui de Joaquin Phoenix)</h2><p>Tout va bien jusqu&#039;Ã  ce qu&#039;on se rappelle un petit Ã©lÃ©ment d&#039;importance : notre jeu de 52 cartes en contient en vÃ©ritÃ© 54, puisqu&#039;il y a les deux jokers (le rouge et le noir). Et comme je veux jouer au <a href="https://www.maison-facile.com/magazine/multimedia/se-divertir/jouer-entre-amis/188-jeux-de-cartes-le-8-americain/" target="_blank">8 amÃ©ricain</a>, j&#039;en ai besoin ! Modifions donc notre modÃ¨le :</p><pre><code class="lang-java">public enum Value {
   ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, 
   EIGHT, NINE, TEN, JACK, QUEEN, KING, JOKER;
}

public enum Color {
   HEARTS, CLUBS, SPADES, DIAMONDS, RED, BLACK;
}</code></pre><p>Avez-vous remarquÃ© ce qu&#039;il vient de se passer ? Notre type <code>Value</code> contient maintenant <code>14</code> valeurs possibles, et le type <code>Color</code> en contient 6. Si on les combine, on se rend compte que notre type <code>Card</code> peut reprÃ©senter <code>14 * 6 = 84</code> valeurs ! On a donc 30 valeurs impossibles qui se sont glissÃ©s avec nos <code>52 + 2 = 54</code> valeurs possibles. Encore une fois, il faudra faire des vÃ©rifications dans le code...</p><p>Ou peut-Ãªtre que non ?</p><h2>Les types algÃ©briques </h2><p>Rappelez-vous : combiner deux valeurs dans un objet revient Ã  multiplier les cas possibles de chacune de ces valeurs :</p><pre><code class="lang-java">public class Card {
   public Value value;
   public Color color;
}
// Value * Color = 13 * 4 = 52</code></pre><p>Le nombre de valeurs possibles d&#039;un type s&#039;appelle la <strong>cardinalitÃ©</strong>. Ici, la cardinalitÃ© du type <code>Value</code> est 13 (= il peut avoir 13 valeurs diffÃ©rentes), celle du type <code>Color</code> est 4 et celle du type <code>Card</code> est 52.</p><p>Pour obtenir 54 valeurs possibles et reprÃ©senter nos deux jokers, on aimerait idÃ©alement pouvoir avoir une cardinalitÃ© de <code>52 + 2 = 54</code>. Or, nous savons uniquement <em>multipler</em> les cardinalitÃ©s des types, pas les additionner ! Vraiment ? Ce n&#039;est pas si sÃ»r !</p><p>Si on ajoutait simplement une nouvelle couleur, notre type <code>Color</code> deviendrait ainsi :</p><pre><code>public enum Color {
   HEARTS, CLUBS, SPADES, DIAMONDS, NEW_COLOR;
}</code></pre><p>Sa cardinalitÃ© devient donc <code>4 + 1 = 5</code>. Eh oui, ajouter 1 membre Ã  un enum Ã©quivaut Ã  ajouter 1 Ã  sa cardinalitÃ© !</p><p>Prenons maintenant un peu de recul. Pour dÃ©crire le type <code>Color</code> en bon franglais, on pourrait dire ceci :</p><blockquote><p><code>Color</code> est un type qui peut valoir <code>HEARTS</code> <strong>ou</strong> <code>CLUBS</code> <strong>ou</strong> <code>SPADES</code> <strong>ou</strong> <code>DIAMONDS</code> <strong>ou</strong> <code>NEW_COLOR</code>.</p></blockquote><p>A l&#039;inverse, on constate que notre type <code>Card</code> serait plutÃ´t dÃ©crit de la faÃ§on suivante :</p><blockquote><p><code>Card</code> est un type composÃ© d&#039;une <code>Value</code> <strong>et</strong> d&#039;une <code>Color</code>.</p></blockquote><p>Intuitivement, on comprend donc qu&#039;un &quot;<strong>ou</strong>&quot; revient Ã  <em>additionner</em> les cardinalitÃ©s, alors qu&#039;un &quot;<strong>et</strong>&quot; revient Ã  <em>multipler</em> les cardinalitÃ©s !</p><p>Mais alors comment dÃ©crire  notre type <code>Card</code> contenant les deux jokers ? VoilÃ  ce que je propose :</p><blockquote><p>Card est un type qui peut valoir <code>BLACK_JOKER</code> <strong>ou</strong> <code>RED_JOKER</code> <strong>ou</strong> Ãªtre composÃ© d&#039;une <code>Value</code> <strong>et</strong> d&#039;une <code>Color</code>.</p></blockquote><p>On voit donc qu&#039;on souhaite <em>additionner</em> trois Ã©lÃ©ments diffÃ©rents, dont le dernier est une <em>multiplication</em> de deux Ã©lÃ©ments. Quelque chose comme Ã§a :</p><pre><code class="lang-java">public enum Card {
   BLACK_JOKER, RED_JOKER, SIMPLE_CARD(Value, Color);
}</code></pre><p>Sauf qu&#039;Ã©videmment, cette syntaxe n&#039;est pas du Java valide ! Il s&#039;agit d&#039;un <strong>type algÃ©brique</strong>, c&#039;est-Ã -dire un type composÃ© d&#039;autres types, soit en les additionnant (on parle alors de <em>types somme ou sum type</em>), soit en les multipliant (on parle alors de <em>types produit ou product type</em>). </p><p>Ils ne sont malheureusement pas supportÃ©s dans tous les langages. VoilÃ  comment on pourrait le reprÃ©senter en [Elm, un langage front-end compilant en JavaScript](./ce-que-jaime-en-elm) :</p><pre><code class="lang-elm">type Card =
   BlackJoker 
   | RedJoker
   | SimpleCard Value Color</code></pre><p>On peut ensuite utiliser ce type :</p><pre><code class="lang-elm">myBlackJoker = BlackJoker
myTenOfClubs = SimpleCard Ten Clubs</code></pre><p>Il n&#039;est ainsi plus possible de reprÃ©senter de valeurs impossibles dans notre programme ! La cardinalitÃ© de notre reprÃ©sentation est Ã©gale Ã  la cardinalitÃ© du problÃ¨me mÃ©tier qu&#039;on souhaite reprÃ©senter. On peut donc Ã©viter partout dans le code des vÃ©rifications manuelles : si on possÃ¨de une valeur de type <code>Card</code>, celle-ci est forcÃ©ment valide. C&#039;est toute une catÃ©gorie de bugs Ã©vitÃ©e !</p><p>Les langages supportant les <em>types algÃ©briques</em> sont par exemple Rust, Haskell, Scala, OCaml, Elm, ReasonML, etc. Ce sont surtout des langages fonctionnels. Certains les utilisent plus ou moins en <a href="https://proandroiddev.com/algebraic-data-types-in-kotlin-337f22ef230a" target="_blank">Kotlin</a> Ã©galement.</p><h2>J&#039;ai menti...</h2><p>Il faut que je fasse un aveu : je vous ai menti dans les premiÃ¨res parties de cet article. Plus exactement en parlant du code suivant :</p><pre><code class="lang-java">public enum Value {
   ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, 
   EIGHT, NINE, TEN, JACK, QUEEN, KING;
}

public enum Color {
   HEARTS, CLUBS, SPADES, DIAMONDS;
}

public class Card {
   public Value value;
   public Color color;
}</code></pre><p>Je vous ai affirmÃ© que la cardinalitÃ© du type <code>Card</code> Ã©tait de <code>13 * 4 = 52</code>, mais ce n&#039;est pas le cas. En effet, nous sommes en Java et il faut donc compter avec la possibilitÃ© que les valeurs soient <code>null</code>. On a donc 5 valeurs possibles pour la <code>Color</code> (<code>HEARTS</code>, <code>CLUBS</code>, <code>SPADES</code>, <code>DIAMONDS</code> et <code>null</code>) et 14 valeurs possibles pour la <code>Value</code>, ce qui nous fait une cardinalitÃ© de <code>14 * 5 = 70</code>, bien au-delÃ  de la cardinalitÃ© qu&#039;on cherchait Ã  reprÃ©senter !</p><p><code>null</code> est censÃ© reprÃ©senter une valeur qui n&#039;est pas prÃ©sente, souvent parce qu&#039;elle n&#039;a pas Ã©tÃ© initialisÃ©e. Mais cette valeur est un peu magique : <code>null</code> peut Ãªtre de n&#039;importe quel type et on doit donc le compter dans toutes nos cardinalitÃ©s. </p><p>Beaucoup d&#039;exceptions et de bugs sont dus Ã  ces valeurs <code>null </code>en Java, parce que le dÃ©veloppeur oublie de les gÃ©rer. En JavaScript, c&#039;est mÃªme pire, puisqu&#039;on a <code>null</code> et <code>undefined</code>` Ã  prendre en compte ! A tel point que des langages ont dÃ©cidÃ© de ne pas avoir cette <em>valeur joker</em> dans le langage. </p><p>Mais alors comment reprÃ©senter une valeur qui peut Ãªtre dÃ©finie ou non ? Essayons en toutes lettres de dÃ©finir une chaine de caractÃ¨res qui peut ne pas Ãªtre dÃ©finie :</p><blockquote><p>C&#039;est une valeur qui peut valoir <code>null</code> <strong>ou</strong> contenir une <code>String</code></p></blockquote><p>Est-ce que Ã§a ne ressemble pas Ã  un <strong>type somme</strong> ? Et effectivement, c&#039;est comme Ã§a que ces langages le dÃ©finissent, petit exemple en Elm :</p><pre><code class="lang-elm">type MaybeString = 
   Nothing
   | Just String</code></pre><p>On voit que la valeur est soit <code>Nothing</code>, soit un <code>Just</code> contenant notre chaine de caractÃ¨res. Et Ã§a fait toute la diffÃ©rence avec le <code>null</code> de Java : partout oÃ¹ une valeur peut ne pas Ãªtre dÃ©finie, le dÃ©veloppeur doit l&#039;indiquer dans son type (en utilisant <code>MaybeString</code> au lieu de <code>String</code> par exemple). Comme c&#039;est <em>explicite</em>, le compilateur peut donc vous forcer Ã  gÃ©rer le cas, Ã©vitant un bug dÃ» Ã  l&#039;inattention d&#039;un dÃ©veloppeur !</p><p>J&#039;ai menti une seconde fois : le type <code>MaybeString</code> n&#039;existe pas en Elm. Il s&#039;agit en fait d&#039;un type <code>Maybe</code> gÃ©nÃ©rique qui prend en argument un type (<code>a</code> dans l&#039;exemple ci-dessous) pour retourner un <code>Maybe a</code>. Cela Ã©vite de redÃ©finir un <code>MaybeInt</code>, un <code>MaybeString</code>, un <code>MaybeCard</code>... Voyez le <code>a</code> comme une variable reprÃ©sentant un type.</p><pre><code class="lang-elm">type Maybe a =
   Nothing
   | Just a

myCard : Maybe Card -- indique le type de myCard
myCard = Just RedJoker</code></pre><p>C&#039;est fini, plus de mensonges entre nous !</p><h2>Des applications d&#039;exception</h2><p>La grande force des types algÃ©briques, c&#039;est qu&#039;ils vous donnent les moyens de modÃ©liser votre modÃ¨le de faÃ§on beaucoup plus prÃ©cise ! Nous l&#039;avons vu pour le cas des valeurs qui peuvent Ãªtre non dÃ©finies, mais les applications sont trÃ¨s nombreuses.</p><p>Par exemple, prenons une opÃ©ration qui peut Ã©chouer : nous essayons de lire le contenu d&#039;un fichier. Cette requÃªte peut Ã©chouer de diffÃ©rentes maniÃ¨res : le fichier n&#039;existe pas, le programme n&#039;a pas les droits en lecture, le fichier est bloquÃ© par une autre ressource, .... Dans certains langages, la faÃ§on de gÃ©rer ces erreurs est toute trouvÃ©e : les <strong>exceptions</strong>. En Java notamment, il faut <strong>penser</strong> Ã  gÃ©rer ces exceptions avec un bloc <code>try...catch</code> :</p><pre><code class="lang-java">try {
   Files.readAllLines(filePath, UTF_8);`
} catch (IOException e) {
   // gestion de l&#039;erreur
}</code></pre><p>C&#039;est ici acceptable parce que le compilateur force l&#039;utilisateur Ã  gÃ©rer cette <code>IOException</code> explicitement, soit avec ce bloc <code>try...catch</code>, soit en indiquant dans la dÃ©finition de la fonction que celle-ci peut renvoyer une exception. Cependant, en lisant <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines(java.nio.file.Path,%20java.nio.charset.Charset%29" target="_blank">la documentation de <code>Files.readAllLines</code></a>, on se rend compte qu&#039;il existe un second type d&#039;exception, <code>SecurityException</code> qui est une <code>RuntimeException</code>.</p><p>Pour ceux qui ne font pas de Java, cela veut dire que le dÃ©veloppeur n&#039;est pas <em>obligÃ©</em> de gÃ©rer cette erreur. Et j&#039;irai mÃªme plus loin : rien n&#039;est fait pour que le dÃ©veloppeur ait <em>conscience</em> que cette erreur peut se produire ! Il est dÃ¨s lors possible que ces erreurs se manifestent en production.</p><p>Une exception va remonter la pile d&#039;appels jusqu&#039;Ã  ce qu&#039;elle soit attrapÃ©e par un <code>try...catch</code> ou remonter jusqu&#039;Ã  l&#039;utilisateur le cas Ã©chÃ©ant. Dans de plus en plus de langages, on a tendance Ã  ne plus utiliser d&#039;exceptions Ã  cause de ce cÃ´tÃ© <em>magique</em> et implicite. Pour rendre cela explicite, on fait porter cette information par le type de retour de notre fonction, comme on pouvait le faire plus haut avec un <code>Maybe String</code> pour une valeur pouvant Ãªtre non dÃ©finie.</p><p>En Rust par exemple, il existe un type <code>Result</code> :</p><pre><code class="lang-rust">enum Result&lt;T, E&gt; {
   Ok(T),
   Err(E),
}</code></pre><p><code>T</code> et <code>E</code> sont des variables de types, cela signifie donc que notre valeur de type <code>Result</code> est soit un <code>Ok</code> contenant une valeur de type <code>T</code>, soit un <code>Err</code> de  type <code>E</code>. DÃ¨s lors, le dÃ©veloppeur est obligÃ© d&#039;extraire cette valeur et donc de considÃ©rer et gÃ©rer le cas d&#039;erreur de faÃ§on explicite.</p><p>La signature de la fonction <code>read</code> en Rust est du coup la suivante :</p><pre><code class="lang-rust">fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize, io::Error&gt;</code></pre><p>La seule partie importante pour nous est le retour : on reÃ§oit un <code>Result</code> qui, en cas de succÃ¨s va Ãªtre un <code>Ok</code> contenant un <code>usize</code> (un pointeur en mÃ©moire vers le rÃ©sultat) et en cas d&#039;Ã©chec va Ãªtre un <code>Err</code> contenant la cause de l&#039;erreur de type <code>io::Error</code>.</p><p>On voit ici qu&#039;en plus de sÃ©curiser le dÃ©veloppement de l&#039;application en forÃ§ant le dÃ©veloppeur Ã  gÃ©rer les cas d&#039;erreur, le type <code>Result</code> joue le rÃ´le de <strong>documentation</strong> du code : on <em>sait</em> que cette mÃ©thode peut Ã©chouer en lisant la signature.</p><h2>Je perds la <code>bool</code></h2><p>Mais pas besoin d&#039;avoir des <em>types algÃ©briques</em> pour amÃ©liorer son code grÃ¢ce aux types, on peut dÃ©jÃ  aller loin avec des <code>enum</code>s. Regardons cette fonction en Java, permettant de commander un produit en ligne :</p><pre><code class="lang-java">public Order orderProduct(Product product, boolean withGiftWrap) {
   // ...
}

orderProduct(book, true);</code></pre><p>On peut remarquer deux choses : la fonction retourne un <code>Order</code>, alors que d&#039;expÃ©rience, ce genre de mÃ©thode peut sÃ»rement Ã©chouer pour de nombreuses raisons diffÃ©rentes. Cela signifie que cette mÃ©thode a de grandes chances de lancer des exceptions en cas d&#039;erreur ! Mais passons, c&#039;est le second point qui nous intÃ©resse ici : si on ne voit que l&#039;appel de la fonction, on peut se demander ce que signifie ce <code>true</code> passÃ© en second argument.  La seule faÃ§on de le savoir est d&#039;aller voir la dÃ©finition de la fonction pour constater qu&#039;il s&#039;agit de l&#039;ajout ou non de papier cadeau. On appelle cela <em>boolean blindness</em>.</p><p>Souvent, les boolÃ©ens sont utilisÃ©s par facilitÃ©, alors que l&#039;utilisation d&#039;un enum amÃ©liorerait de beaucoup la lisibilitÃ© :</p><pre><code class="lang-java">public enum GiftWrap {
   NO_GIFT_WRAP, WITH_GIFT_WRAP;
}

public Order orderProduct(Product product, GiftWrap giftWrap) {
   // ...
}

orderProduct(book, WITH_GIFT_WRAP);</code></pre><p>N&#039;est-ce pas plus lisible ? Et surtout cela nous permettra d&#039;Ã©voluer plus facilement : si demain on souhaite laisser le choix entre deux types de papier cadeaux, on peut juste rajouter des Ã©lÃ©ments Ã  l&#039;enum.</p><pre><code class="lang-java">public enum GiftWrap {
   NO_GIFT_WRAP, CHILD_GIFT_WRAP, ADULT_GIFT_WRAP;
}</code></pre><p>A chaque fois qu&#039;on se retrouve Ã  utiliser des boolÃ©ens, il faut se demander si notre intention ne serait pas plus clair avec un enum explicitant vraiment la valeur mÃ©tier.</p><h2>L&#039;appliquer dÃ¨s aujourd&#039;hui</h2><p>Si vous avez l&#039;occasion d&#039;utiliser un langage avec des types algÃ©briques qui correspond Ã  votre problÃ¨me, foncez ! Ce n&#039;est cependant pas toujours le cas, et bien qu&#039;il soit possible d&#039;Ã©muler leur fonctionnement dans certains langages, la crÃ©ation est souvent peu pratique.</p><p>Cependant, on trouve dans tous les langages des bibliothÃ¨ques d&#039;utilitaires fournissant des Ã©lÃ©ments comme le <code>Maybe</code> (parfois appelÃ© <code>Option</code> ou <code>Optional</code>) et le <code>Result</code> (parfois appelÃ© <code>Either</code>,  <code>Try</code> s&#039;il est  spÃ©cialisÃ© pour des exceptions). C&#039;est le cas en Java notamment avec <a href="https://www.vavr.io/" target="_blank">l&#039;excellente bibliothÃ¨que Vavr</a>. En TypeScript, vous pouvez Ã©galement activer l&#039;option <a href="https://basarat.gitbooks.io/typescript/docs/options/strictNullChecks.html" target="_blank"><code>strictNullChecks</code></a> qui ajoute plus de vÃ©rifications sur les <code>null</code> et <code>undefined</code>.</p><p>Dans tous les cas, mon premier conseil est le suivant : dÃ©barrassez-vous de <code>null</code>. Rendez  l&#039;absence de valeur explicite et vous Ã©viterez beaucoup de problÃ¨mes. Faites de mÃªme avec les exceptions.</p><p>Mon second conseil est d&#039;Ã©viter au maximum la <em>primitive obsession</em> : n&#039;hÃ©sitez pas Ã  crÃ©er des objets / enums plutÃ´t que d&#039;utiliser les types primitifs comme <code>string</code>, <code>bool</code> et <code>number</code>. Il me semble avoir vu un jour cette citation dont je ne connais ni l&#039;origine ni l&#039;auteur et que j&#039;ai peut-Ãªtre involontairement dÃ©formÃ©e (n&#039;hÃ©sitez pas Ã  m&#039;envoyer la rÃ©fÃ©rence si vous l&#039;avez) :</p><blockquote><p>Quand vous Ã©crivez qu&#039;une fonction prend un <code>string</code> en argument, votre fonction <em>doit</em> accepter l&#039;intÃ©gralitÃ© des oeuvres de Shakespeare en mandarin en paramÃ¨tre.</p></blockquote><p>Et mon dernier conseil est sans doute le plus important : essayez de rendre possible uniquement les valeurs que votre mÃ©tier accepte ; Ã©liminez grÃ¢ce aux types le maximum d&#039;Ã©tats impossibles. En ce sens, je vous recommande cet excellent talk de Richard Feldman (en anglais) : <a href="https://www.youtube.com/watch?v=IcgmSRJHu_8" target="_blank">Making impossible states impossible</a>.</p><p><strong>Cet article possÃ¨de une seconde partie, </strong><a elm-pages:prefetch="" href="/blog/des-types-au-top-2"><span class="elm-css-style-wrapper" style="display: none;"><style></style></span><span><strong>cliquez ici pour lire la suite</strong></span></a><strong>.</strong></p></div></div></section><aside class="author-card"><img class="author-picture" src="https://www.datocms-assets.com/53557/1630943458-profil-200.jpg?crop64=Zm9jYWxwb2ludCxmYWNlcyxlbnRyb3B5&fit=crop&h=80&mask=ellipse&w=80"><p class="author-description">Passionate web developer, caring for user experience and code quality. In this blog, I share my discoveries and reflexions.</p></aside></main><footer class="container footer"><div class="footerContent"><p><em>Blog powered by <a href="https://elm-pages.com/">elm-pages</a></em></p></div></footer></div>
    </body>
  </html>
  