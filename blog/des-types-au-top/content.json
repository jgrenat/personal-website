{"is404":false,"staticData":{"420756529":"{\"items\":[{\"id\":{\"videoId\":\"V2DgGyH6D_k\"}},{\"id\":{\"videoId\":\"Zp4p7DiWMuA\"}},{\"id\":{\"videoId\":\"WToGeMIdoSY\"}},{\"id\":{\"videoId\":\"AQkCgGajhxg\"}},{\"id\":{\"videoId\":\"uFzBmBoSrS0\"}}]}","1142833480":"{\"title\":\"[Code in the Unknown] Adding a \\\"cancel\\\" action to a chess game\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/Zp4p7DiWMuA/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/Zp4p7DiWMuA?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"[Code in the Unknown] Adding a &quot;cancel&quot; action to a chess game\\\"></iframe>\"}","2243736650":"{\"title\":\"Discovering Supabase, a Firebase alternative based on PostgreSQL (part 2)\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/V2DgGyH6D_k/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/V2DgGyH6D_k?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Discovering Supabase, a Firebase alternative based on PostgreSQL (part 2)\\\"></iframe>\"}","2730572102":"{\"title\":\"Creating a Elm package for DatoCMS (part 3)\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/uFzBmBoSrS0/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/uFzBmBoSrS0?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Creating a Elm package for DatoCMS (part 3)\\\"></iframe>\"}","2886442429":"{\"title\":\"Discovering Supabase, a Firebase alternative based on PostgreSQL\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/WToGeMIdoSY/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/WToGeMIdoSY?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Discovering Supabase, a Firebase alternative based on PostgreSQL\\\"></iframe>\"}","2986682595":"{\"title\":\"Creating a Elm package for DatoCMS (last part)\",\"thumbnail_height\":360,\"thumbnail_width\":480,\"thumbnail_url\":\"https://i.ytimg.com/vi/AQkCgGajhxg/hqdefault.jpg\",\"html\":\"<iframe width=\\\"200\\\" height=\\\"113\\\" src=\\\"https://www.youtube.com/embed/AQkCgGajhxg?feature=oembed\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\\" allowfullscreen title=\\\"Creating a Elm package for DatoCMS (last part)\\\"></iframe>\"}","3075083330":"{\"data\":{\"homePage\":{\"picture\":{\"url4062855192\":\"https://www.datocms-assets.com/53557/1630943458-profil-200.jpg?crop64=Zm9jYWxwb2ludCxmYWNlcyxlbnRyb3B5&fit=crop&h=80&mask=ellipse&w=80\"},\"introductionText12867311\":\"Passionate web developer, caring for user experience and code quality. In this blog, I share my discoveries and reflexions.\"},\"article3839572416\":{\"name1875757806\":\"üá´üá∑  Des types au top\",\"banner\":{\"url1984142787\":\"https://www.datocms-assets.com/53557/1628436466-types.jpg?fit=crop&max-h=250&max-w=800\"},\"content103746919\":{\"value3343696236\":{\"schema\":\"dast\",\"document\":{\"type\":\"root\",\"children\":[{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Le commencement\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Ayant d√©but√© avec PHP et JavaScript, j'ai longtemps cru que les types se limitaient en programmation √† ce que j'en voyais alors : une donn√©e peut √™tre un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"number\"},{\"type\":\"span\",\"value\":\", une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"string\"},{\"type\":\"span\",\"value\":\", un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"bool\"},{\"type\":\"span\",\"value\":\", une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"list\"},{\"type\":\"span\",\"value\":\" ou  un object. Toute donn√©e dans mes programmes √©tait une composition de ces diff√©rents √©l√©ments.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Par exemple, la repr√©sentation d'un dix de coeur dans un jeu de cartes pouvait √™tre :\"}]},{\"code\":\"const tenOfHeart = { value: 10, color: 'hearts' };\",\"type\":\"code\",\"language\":\"javascript\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Mais alors comment repr√©senter un valet de coeur ? Tout simplement en consid√©rant qu'un valet vaut \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"11\"},{\"type\":\"span\",\"value\":\" !\"}]},{\"code\":\"const jackOfHeart = { value: 11, color: 'hearts' };\",\"type\":\"code\",\"language\":\"javascript\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Cela ne me choquait pas √† l'√©poque. En regardant ce type de code aujourd'hui, deux consid√©rations me viennent imm√©diatement √† l'esprit. La premi√®re est que ce mod√®le va nous obliger √† avoir une traduction mentale de nos valeurs : partout o√π on veut repr√©senter un valet, on doit se souvenir qu'il correspond au \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"11\"},{\"type\":\"span\",\"value\":\" , puis la dame au \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"12\"},{\"type\":\"span\",\"value\":\", etc. C'est un effort cognitif √† produire en plus et une chance de plus de commettre une erreur. Donc un bug !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"L'autre consid√©ration est plus pr√©occupante : si la dame vaut \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"12\"},{\"type\":\"span\",\"value\":\", le roi \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"13\"},{\"type\":\"span\",\"value\":\" et l'as \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"1\"},{\"type\":\"span\",\"value\":\", que valent ces cartes ?\"}]},{\"code\":\"const wtfOfHeart = { value: 199, color: 'hearts' };\\nconst what = { value: 2.6, color: 'hearts' };\\nconst areYouKidding = { value: NaN, color: 'green' };\",\"type\":\"code\",\"language\":\"javascript\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Et c'est l√† l'un des principaux probl√®mes des types basiques : mis √† part le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"bool\"},{\"type\":\"span\",\"value\":\" qui peut avoir deux valeurs (\"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"true\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"false\"},{\"type\":\"span\",\"value\":\"), tous les autres types peuvent avoir virtuellement une infinit√© de valeurs possibles ! Or, il n'existe que 52 cartes dans le jeu classique qu'on souhaite repr√©senter ! \"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Notre repr√©sentation d'une carte peut donc avoir une infinit√© de valeurs possibles alors qu'on souhaite en g√©rer 52 au maximum. Il s'ensuit qu'il existe une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"infinit√© - 52 = toujours une infinit√©\"},{\"type\":\"span\",\"value\":\" de valeurs absurdes qui peuvent perturber l'ex√©cution de notre programme ! Ce qui va nous obliger aux emplacements strat√©giques √† effectuer des v√©rifications üòÄ\"}]},{\"code\":\"const validColors = ['hearts', 'spades', 'clubs', 'diamonds'];\\nfunction playCard(card) {\\n   if (card.value < 1 || card.value > 13 \\n      || !validColors.includes(card.colors)) {\\n      throw new Error('Invalid card!')\\n   }\\n   // ...\\n}\",\"type\":\"code\",\"language\":\"javascript\"},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Java √† la rescousse\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"J'ai plus tard appris Java, d√©couvrant au passage les \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"enum\"},{\"type\":\"span\",\"value\":\"s. C'est une fa√ßon bien pratique de repr√©senter un nombre fini de valeurs, ce qui nous donne au final üòÄ\"}]},{\"code\":\"public enum Value {\\n   ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, \\n   EIGHT, NINE, TEN, JACK, QUEEN, KING;\\n}\\n\\npublic enum Color {\\n   HEARTS, CLUBS, SPADES, DIAMONDS;\\n}\\n\\npublic class Card {\\n   public Value value;\\n   public Color color;\\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Les choses s'am√©liorent ! Si on regarde le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\", on se rend compte qu'il contient seulement 13 valeurs possibles et le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\" peut prendre 4 valeurs diff√©rentes. Le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\" √©tant compos√© d'une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\" et d'une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\", on peut donc repr√©senter la combinaison des deux, c'est-√†-dire \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"13 * 4 = 52\"},{\"type\":\"span\",\"value\":\" valeurs diff√©rentes. Voyez comme les possibilit√©s des types se \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"multiplient\"},{\"type\":\"span\",\"value\":\" quand on les combine !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Et √ßa tombe bien, notre jeu contient 52 cartes diff√©rentes, on peut donc uniquement mod√©liser des cartes valides ! Cela signifie qu'il n'est pas n√©cessaire de v√©rifier par la suite que notre carte est valide, comme c'√©tait le cas avant. On gagne en s√©curit√© dans notre code en ne permettant pas de repr√©senter des √©tats non coh√©rents, que nous appellerons \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"√©tats impossibles\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On gagne aussi en clart√© en lisant le code : plus besoin de faire un effort mental pour convertir \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"11\"},{\"type\":\"span\",\"value\":\" en \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Jack\"},{\"type\":\"span\",\"value\":\", puisque dans le code nous utilisons directement \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"JACK\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Le joker (pas celui de Joaquin Phoenix)\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Tout va bien jusqu'√† ce qu'on se rappelle un petit √©l√©ment d'importance : notre jeu de 52 cartes en contient en v√©rit√© 54, puisqu'il y a les deux jokers (le rouge et le noir). Et comme je veux jouer au \"},{\"url\":\"https://www.maison-facile.com/magazine/multimedia/se-divertir/jouer-entre-amis/188-jeux-de-cartes-le-8-americain/\",\"meta\":[{\"id\":\"target\",\"value\":\"_blank\"}],\"type\":\"link\",\"children\":[{\"type\":\"span\",\"value\":\"8 am√©ricain\"}]},{\"type\":\"span\",\"value\":\", j'en ai besoin ! Modifions donc notre mod√®le :\"}]},{\"code\":\"public enum Value {\\n   ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, \\n   EIGHT, NINE, TEN, JACK, QUEEN, KING, JOKER;\\n}\\n\\npublic enum Color {\\n   HEARTS, CLUBS, SPADES, DIAMONDS, RED, BLACK;\\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Avez-vous remarqu√© ce qu'il vient de se passer ? Notre type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\" contient maintenant \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"14\"},{\"type\":\"span\",\"value\":\" valeurs possibles, et le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\" en contient 6. Si on les combine, on se rend compte que notre type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\" peut repr√©senter \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"14 * 6 = 84\"},{\"type\":\"span\",\"value\":\" valeurs ! On a donc 30 valeurs impossibles qui se sont gliss√©s avec nos \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"52 + 2 = 54\"},{\"type\":\"span\",\"value\":\" valeurs possibles. Encore une fois, il faudra faire des v√©rifications dans le code...\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Ou peut-√™tre que non ?\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Les types alg√©briques \"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Rappelez-vous : combiner deux valeurs dans un objet revient √† multiplier les cas possibles de chacune de ces valeurs :\"}]},{\"code\":\"public class Card {\\n   public Value value;\\n   public Color color;\\n}\\n// Value * Color = 13 * 4 = 52\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Le nombre de valeurs possibles d'un type s'appelle la \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"cardinalit√©\"},{\"type\":\"span\",\"value\":\". Ici, la cardinalit√© du type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\" est 13 (= il peut avoir 13 valeurs diff√©rentes), celle du type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\" est 4 et celle du type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\" est 52.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Pour obtenir 54 valeurs possibles et repr√©senter nos deux jokers, on aimerait id√©alement pouvoir avoir une cardinalit√© de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"52 + 2 = 54\"},{\"type\":\"span\",\"value\":\". Or, nous savons uniquement \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"multipler\"},{\"type\":\"span\",\"value\":\" les cardinalit√©s des types, pas les additionner ! Vraiment ? Ce n'est pas si s√ªr !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Si on ajoutait simplement une nouvelle couleur, notre type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\" deviendrait ainsi :\"}]},{\"code\":\"public enum Color {\\n   HEARTS, CLUBS, SPADES, DIAMONDS, NEW_COLOR;\\n}\",\"type\":\"code\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Sa cardinalit√© devient donc \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"4 + 1 = 5\"},{\"type\":\"span\",\"value\":\". Eh oui, ajouter 1 membre √† un enum √©quivaut √† ajouter 1 √† sa cardinalit√© !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Prenons maintenant un peu de recul. Pour d√©crire le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\" en bon franglais, on pourrait dire ceci :\"}]},{\"type\":\"blockquote\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\" est un type qui peut valoir \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"HEARTS\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"CLUBS\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"SPADES\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"DIAMONDS\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"NEW_COLOR\"},{\"type\":\"span\",\"value\":\".\"}]}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"A l'inverse, on constate que notre type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\" serait plut√¥t d√©crit de la fa√ßon suivante :\"}]},{\"type\":\"blockquote\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\" est un type compos√© d'une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"et\"},{\"type\":\"span\",\"value\":\" d'une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\".\"}]}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Intuitivement, on comprend donc qu'un \\\"\"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\"\\\" revient √† \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"additionner\"},{\"type\":\"span\",\"value\":\" les cardinalit√©s, alors qu'un \\\"\"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"et\"},{\"type\":\"span\",\"value\":\"\\\" revient √† \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"multipler\"},{\"type\":\"span\",\"value\":\" les cardinalit√©s !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Mais alors comment d√©crire  notre type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\" contenant les deux jokers ? Voil√† ce que je propose :\"}]},{\"type\":\"blockquote\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Card est un type qui peut valoir \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"BLACK_JOKER\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"RED_JOKER\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" √™tre compos√© d'une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"et\"},{\"type\":\"span\",\"value\":\" d'une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\".\"}]}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On voit donc qu'on souhaite \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"additionner\"},{\"type\":\"span\",\"value\":\" trois √©l√©ments diff√©rents, dont le dernier est une \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"multiplication\"},{\"type\":\"span\",\"value\":\" de deux √©l√©ments. Quelque chose comme √ßa :\"}]},{\"code\":\"public enum Card {\\n   BLACK_JOKER, RED_JOKER, SIMPLE_CARD(Value, Color);\\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Sauf qu'√©videmment, cette syntaxe n'est pas du Java valide ! Il s'agit d'un \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"type alg√©brique\"},{\"type\":\"span\",\"value\":\", c'est-√†-dire un type compos√© d'autres types, soit en les additionnant (on parle alors de \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"types somme ou sum type\"},{\"type\":\"span\",\"value\":\"), soit en les multipliant (on parle alors de \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"\\u001dtypes produit ou product type\"},{\"type\":\"span\",\"value\":\"). \"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Ils ne sont malheureusement pas support√©s dans tous les langages. Voil√† comment on pourrait le repr√©senter en [Elm, un langage front-end compilant en JavaScript](./ce-que-jaime-en-elm) :\"}]},{\"code\":\"type Card =\\n   BlackJoker \\n   | RedJoker\\n   | SimpleCard Value Color\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On peut ensuite utiliser ce type :\"}]},{\"code\":\"myBlackJoker = BlackJoker\\nmyTenOfClubs = SimpleCard Ten Clubs\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Il n'est ainsi plus possible de repr√©senter de valeurs impossibles dans notre programme ! La cardinalit√© de notre repr√©sentation est √©gale √† la cardinalit√© du probl√®me m√©tier qu'on souhaite repr√©senter. On peut donc √©viter partout dans le code des v√©rifications manuelles : si on poss√®de une valeur de type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\", celle-ci est forc√©ment valide. C'est toute une cat√©gorie de bugs √©vit√©e !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Les langages supportant les \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"types alg√©briques\"},{\"type\":\"span\",\"value\":\" sont par exemple Rust, Haskell, Scala, OCaml, Elm, ReasonML, etc. Ce sont surtout des langages fonctionnels. Certains les utilisent plus ou moins en \"},{\"url\":\"https://proandroiddev.com/algebraic-data-types-in-kotlin-337f22ef230a\",\"meta\":[{\"id\":\"target\",\"value\":\"_blank\"}],\"type\":\"link\",\"children\":[{\"type\":\"span\",\"value\":\"Kotlin\"}]},{\"type\":\"span\",\"value\":\" √©galement.\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"J'ai menti...\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Il faut que je fasse un aveu : je vous ai menti dans les premi√®res parties de cet article. Plus exactement en parlant du code suivant :\"}]},{\"code\":\"public enum Value {\\n   ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, \\n   EIGHT, NINE, TEN, JACK, QUEEN, KING;\\n}\\n\\npublic enum Color {\\n   HEARTS, CLUBS, SPADES, DIAMONDS;\\n}\\n\\npublic class Card {\\n   public Value value;\\n   public Color color;\\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Je vous ai affirm√© que la cardinalit√© du type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Card\"},{\"type\":\"span\",\"value\":\" √©tait de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"13 * 4 = 52\"},{\"type\":\"span\",\"value\":\", mais ce n'est pas le cas. En effet, nous sommes en Java et il faut donc compter avec la possibilit√© que les valeurs soient \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\". On a donc 5 valeurs possibles pour la \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Color\"},{\"type\":\"span\",\"value\":\" (\"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"HEARTS\"},{\"type\":\"span\",\"value\":\", \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"CLUBS\"},{\"type\":\"span\",\"value\":\", \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"SPADES\"},{\"type\":\"span\",\"value\":\", \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"DIAMONDS\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\") et 14 valeurs possibles pour la \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Value\"},{\"type\":\"span\",\"value\":\", ce qui nous fait une cardinalit√© de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"14 * 5 = 70\"},{\"type\":\"span\",\"value\":\", bien au-del√† de la cardinalit√© qu'on cherchait √† repr√©senter !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\" est cens√© repr√©senter une valeur qui n'est pas pr√©sente, souvent parce qu'elle n'a pas √©t√© initialis√©e. Mais cette valeur est un peu magique : \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\" peut √™tre de n'importe quel type et on doit donc le compter dans toutes nos cardinalit√©s. \"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Beaucoup d'exceptions et de bugs sont dus √† ces valeurs \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null \"},{\"type\":\"span\",\"value\":\"en Java, parce que le d√©veloppeur oublie de les g√©rer. En JavaScript, c'est m√™me pire, puisqu'on a \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"undefined\"},{\"type\":\"span\",\"value\":\"` √† prendre en compte ! A tel point que des langages ont d√©cid√© de ne pas avoir cette \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"valeur joker\"},{\"type\":\"span\",\"value\":\" dans le langage. \"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Mais alors comment repr√©senter une valeur qui peut √™tre d√©finie ou non ? Essayons en toutes lettres de d√©finir une chaine de caract√®res qui peut ne pas √™tre d√©finie :\"}]},{\"type\":\"blockquote\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"C'est une valeur qui peut valoir \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\" \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"ou\"},{\"type\":\"span\",\"value\":\" contenir une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"String\"}]}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Est-ce que √ßa ne ressemble pas √† un \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"type somme\"},{\"type\":\"span\",\"value\":\" ? Et effectivement, c'est comme √ßa que ces langages le d√©finissent, petit exemple en Elm :\"}]},{\"code\":\"type MaybeString = \\n   Nothing\\n   | Just String\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On voit que la valeur est soit \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Nothing\"},{\"type\":\"span\",\"value\":\", soit un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Just\"},{\"type\":\"span\",\"value\":\" contenant notre chaine de caract√®res. Et √ßa fait toute la diff√©rence avec le \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\" de Java : partout o√π une valeur peut ne pas √™tre d√©finie, le d√©veloppeur doit l'indiquer dans son type (en utilisant \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"MaybeString\"},{\"type\":\"span\",\"value\":\" au lieu de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"String\"},{\"type\":\"span\",\"value\":\" par exemple). Comme c'est \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"explicite\"},{\"type\":\"span\",\"value\":\", le compilateur peut donc vous forcer √† g√©rer le cas, √©vitant un bug d√ª √† l'inattention d'un d√©veloppeur !\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"J'ai menti une seconde fois : le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"MaybeString\"},{\"type\":\"span\",\"value\":\" n'existe pas en Elm. Il s'agit en fait d'un type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Maybe\"},{\"type\":\"span\",\"value\":\" g√©n√©rique qui prend en argument un type (\"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"a\"},{\"type\":\"span\",\"value\":\" dans l'exemple ci-dessous) pour retourner un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Maybe a\"},{\"type\":\"span\",\"value\":\". Cela √©vite de red√©finir un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"MaybeInt\"},{\"type\":\"span\",\"value\":\", un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"MaybeString\"},{\"type\":\"span\",\"value\":\", un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"MaybeCard\"},{\"type\":\"span\",\"value\":\"... Voyez le \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"a\"},{\"type\":\"span\",\"value\":\" comme une variable repr√©sentant un type.\"}]},{\"code\":\"type Maybe a =\\n   Nothing\\n   | Just a\\n\\nmyCard : Maybe Card -- indique le type de myCard\\nmyCard = Just RedJoker\",\"type\":\"code\",\"language\":\"elm\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"C'est fini, plus de mensonges entre nous !\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Des applications d'exception\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"La grande force des types alg√©briques, c'est qu'ils vous donnent les moyens de mod√©liser votre mod√®le de fa√ßon beaucoup plus pr√©cise ! Nous l'avons vu pour le cas des valeurs qui peuvent √™tre non d√©finies, mais les applications sont tr√®s nombreuses.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Par exemple, prenons une op√©ration qui peut √©chouer : nous essayons de lire le contenu d'un fichier. Cette requ√™te peut √©chouer de diff√©rentes mani√®res : le fichier n'existe pas, le programme n'a pas les droits en lecture, le fichier est bloqu√© par une autre ressource, .... Dans certains langages, la fa√ßon de g√©rer ces erreurs est toute trouv√©e : les \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"exceptions\"},{\"type\":\"span\",\"value\":\". En Java notamment, il faut \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"penser\"},{\"type\":\"span\",\"value\":\" √† g√©rer ces exceptions avec un bloc \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"try...catch\"},{\"type\":\"span\",\"value\":\" :\"}]},{\"code\":\"try {\\n   Files.readAllLines(filePath, UTF_8);`\\n} catch (IOException e) {\\n   // gestion de l'erreur\\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"C'est ici acceptable parce que le compilateur force l'utilisateur √† g√©rer cette \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"IOException\"},{\"type\":\"span\",\"value\":\" explicitement, soit avec ce bloc \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"try...catch\"},{\"type\":\"span\",\"value\":\", soit en indiquant dans la d√©finition de la fonction que celle-ci peut renvoyer une exception. Cependant, en lisant \"},{\"url\":\"https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines(java.nio.file.Path,%20java.nio.charset.Charset%29\",\"meta\":[{\"id\":\"target\",\"value\":\"_blank\"}],\"type\":\"link\",\"children\":[{\"type\":\"span\",\"value\":\"la documentation de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Files.readAllLines\"}]},{\"type\":\"span\",\"value\":\", on se rend compte qu'il existe un second type d'exception, \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"SecurityException\"},{\"type\":\"span\",\"value\":\" qui est une \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"RuntimeException\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Pour ceux qui ne font pas de Java, cela veut dire que le d√©veloppeur n'est pas \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"oblig√©\"},{\"type\":\"span\",\"value\":\" de g√©rer cette erreur. Et j'irai m√™me plus loin : rien n'est fait pour que le d√©veloppeur ait \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"conscience\"},{\"type\":\"span\",\"value\":\" que cette erreur peut se produire ! Il est d√®s lors possible que ces erreurs se manifestent en production.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Une exception va remonter la pile d'appels jusqu'√† ce qu'elle soit attrap√©e par un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"try...catch\"},{\"type\":\"span\",\"value\":\" ou remonter jusqu'√† l'utilisateur le cas √©ch√©ant. Dans de plus en plus de langages, on a tendance √† ne plus utiliser d'exceptions √† cause de ce c√¥t√© \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"magique\"},{\"type\":\"span\",\"value\":\" et implicite. Pour rendre cela explicite, on fait porter cette information par le type de retour de notre fonction, comme on pouvait le faire plus haut avec un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Maybe String\"},{\"type\":\"span\",\"value\":\" pour une valeur pouvant √™tre non d√©finie.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"En Rust par exemple, il existe un type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result\"},{\"type\":\"span\",\"value\":\" :\"}]},{\"code\":\"enum Result<T, E> {\\n   Ok(T),\\n   Err(E),\\n}\",\"type\":\"code\",\"language\":\"rust\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"T\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"E\"},{\"type\":\"span\",\"value\":\" sont des variables de types, cela signifie donc que notre valeur de type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result\"},{\"type\":\"span\",\"value\":\" est soit un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Ok\"},{\"type\":\"span\",\"value\":\" contenant une valeur de type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"T\"},{\"type\":\"span\",\"value\":\", soit un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Err\"},{\"type\":\"span\",\"value\":\" de  type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"E\"},{\"type\":\"span\",\"value\":\". D√®s lors, le d√©veloppeur est oblig√© d'extraire cette valeur et donc de consid√©rer et g√©rer le cas d'erreur de fa√ßon explicite.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"La signature de la fonction \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"read\"},{\"type\":\"span\",\"value\":\" en Rust est du coup la suivante :\"}]},{\"code\":\"fn read(&mut self, buf: &mut [u8]) -> Result<usize, io::Error>\",\"type\":\"code\",\"language\":\"rust\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"La seule partie importante pour nous est le retour : on re√ßoit un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result\"},{\"type\":\"span\",\"value\":\" qui, en cas de succ√®s va √™tre un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Ok\"},{\"type\":\"span\",\"value\":\" contenant un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"usize\"},{\"type\":\"span\",\"value\":\" (un pointeur en m√©moire vers le r√©sultat) et en cas d'√©chec va √™tre un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Err\"},{\"type\":\"span\",\"value\":\" contenant la cause de l'erreur de type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"io::Error\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On voit ici qu'en plus de s√©curiser le d√©veloppement de l'application en for√ßant le d√©veloppeur √† g√©rer les cas d'erreur, le type \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result\"},{\"type\":\"span\",\"value\":\" joue le r√¥le de \"},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"documentation\"},{\"type\":\"span\",\"value\":\" du code : on \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"sait\"},{\"type\":\"span\",\"value\":\" que cette m√©thode peut √©chouer en lisant la signature.\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"Je perds la \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"bool\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Mais pas besoin d'avoir des \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"types alg√©briques\"},{\"type\":\"span\",\"value\":\" pour am√©liorer son code gr√¢ce aux types, on peut d√©j√† aller loin avec des \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"enum\"},{\"type\":\"span\",\"value\":\"s. Regardons cette fonction en Java, permettant de commander un produit en ligne :\"}]},{\"code\":\"public Order orderProduct(Product product, boolean withGiftWrap) {\\n   // ...\\n}\\n\\norderProduct(book, true);\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"On peut remarquer deux choses : la fonction retourne un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Order\"},{\"type\":\"span\",\"value\":\", alors que d'exp√©rience, ce genre de m√©thode peut s√ªrement √©chouer pour de nombreuses raisons diff√©rentes. Cela signifie que cette m√©thode a de grandes chances de lancer des exceptions en cas d'erreur ! Mais passons, c'est le second point qui nous int√©resse ici : si on ne voit que l'appel de la fonction, on peut se demander ce que signifie ce \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"true\"},{\"type\":\"span\",\"value\":\" pass√© en second argument.  La seule fa√ßon de le savoir est d'aller voir la d√©finition de la fonction pour constater qu'il s'agit de l'ajout ou non de papier cadeau. On appelle cela \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"boolean blindness\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Souvent, les bool√©ens sont utilis√©s par facilit√©, alors que l'utilisation d'un enum am√©liorerait de beaucoup la lisibilit√© :\"}]},{\"code\":\"public enum GiftWrap {\\n   NO_GIFT_WRAP, WITH_GIFT_WRAP;\\n}\\n\\npublic Order orderProduct(Product product, GiftWrap giftWrap) {\\n   // ...\\n}\\n\\norderProduct(book, WITH_GIFT_WRAP);\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"N'est-ce pas plus lisible ? Et surtout cela nous permettra d'√©voluer plus facilement : si demain on souhaite laisser le choix entre deux types de papier cadeaux, on peut juste rajouter des √©l√©ments √† l'enum.\"}]},{\"code\":\"public enum GiftWrap {\\n   NO_GIFT_WRAP, CHILD_GIFT_WRAP, ADULT_GIFT_WRAP;\\n}\",\"type\":\"code\",\"language\":\"java\"},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"A chaque fois qu'on se retrouve √† utiliser des bool√©ens, il faut se demander si notre intention ne serait pas plus clair avec un enum explicitant vraiment la valeur m√©tier.\"}]},{\"type\":\"heading\",\"level\":2,\"children\":[{\"type\":\"span\",\"value\":\"L'appliquer d√®s aujourd'hui\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Si vous avez l'occasion d'utiliser un langage avec des types alg√©briques qui correspond √† votre probl√®me, foncez ! Ce n'est cependant pas toujours le cas, et bien qu'il soit possible d'√©muler leur fonctionnement dans certains langages, la cr√©ation est souvent peu pratique.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Cependant, on trouve dans tous les langages des biblioth√®ques d'utilitaires fournissant des √©l√©ments comme le \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Maybe\"},{\"type\":\"span\",\"value\":\" (parfois appel√© \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Option\"},{\"type\":\"span\",\"value\":\" ou \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Optional\"},{\"type\":\"span\",\"value\":\") et le \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Result\"},{\"type\":\"span\",\"value\":\" (parfois appel√© \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Either\"},{\"type\":\"span\",\"value\":\",  \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"Try\"},{\"type\":\"span\",\"value\":\" s'il est  sp√©cialis√© pour des exceptions). C'est le cas en Java notamment avec \"},{\"url\":\"https://www.vavr.io/\",\"meta\":[{\"id\":\"target\",\"value\":\"_blank\"}],\"type\":\"link\",\"children\":[{\"type\":\"span\",\"value\":\"l'excellente biblioth√®que Vavr\"}]},{\"type\":\"span\",\"value\":\". En TypeScript, vous pouvez √©galement activer l'option \"},{\"url\":\"https://basarat.gitbooks.io/typescript/docs/options/strictNullChecks.html\",\"meta\":[{\"id\":\"target\",\"value\":\"_blank\"}],\"type\":\"link\",\"children\":[{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"strictNullChecks\"}]},{\"type\":\"span\",\"value\":\" qui ajoute plus de v√©rifications sur les \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"undefined\"},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Dans tous les cas, mon premier conseil est le suivant : d√©barrassez-vous de \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"null\"},{\"type\":\"span\",\"value\":\". Rendez  l'absence de valeur explicite et vous √©viterez beaucoup de probl√®mes. Faites de m√™me avec les exceptions.\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Mon second conseil est d'√©viter au maximum la \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"primitive obsession\"},{\"type\":\"span\",\"value\":\" : n'h√©sitez pas √† cr√©er des objets / enums plut√¥t que d'utiliser les types primitifs comme \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"string\"},{\"type\":\"span\",\"value\":\", \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"bool\"},{\"type\":\"span\",\"value\":\" et \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"number\"},{\"type\":\"span\",\"value\":\". Il me semble avoir vu un jour cette citation dont je ne connais ni l'origine ni l'auteur et que j'ai peut-√™tre involontairement d√©form√©e (n'h√©sitez pas √† m'envoyer la r√©f√©rence si vous l'avez) :\"}]},{\"type\":\"blockquote\",\"children\":[{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Quand vous √©crivez qu'une fonction prend un \"},{\"type\":\"span\",\"marks\":[\"code\"],\"value\":\"string\"},{\"type\":\"span\",\"value\":\" en argument, votre fonction \"},{\"type\":\"span\",\"marks\":[\"emphasis\"],\"value\":\"doit\"},{\"type\":\"span\",\"value\":\" accepter l'int√©gralit√© des oeuvres de Shakespeare en mandarin en param√®tre.\"}]}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"value\":\"Et mon dernier conseil est sans doute le plus important : essayez de rendre possible uniquement les valeurs que votre m√©tier accepte ; √©liminez gr√¢ce aux types le maximum d'√©tats impossibles. En ce sens, je vous recommande cet excellent talk de Richard Feldman (en anglais) : \"},{\"url\":\"https://www.youtube.com/watch?v=IcgmSRJHu_8\",\"meta\":[{\"id\":\"target\",\"value\":\"_blank\"}],\"type\":\"link\",\"children\":[{\"type\":\"span\",\"value\":\"Making impossible states impossible\"}]},{\"type\":\"span\",\"value\":\".\"}]},{\"type\":\"paragraph\",\"children\":[{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"Cet article poss√®de une seconde partie, \"},{\"item\":\"51975991\",\"type\":\"itemLink\",\"children\":[{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\"cliquez ici pour lire la suite\"}]},{\"type\":\"span\",\"marks\":[\"strong\"],\"value\":\".\"}]}]}},\"blocks\":[],\"links\":[{\"id1492635460\":\"51975991\",\"name12867311\":\"üá´üá∑   Des types au top (2)\",\"slug12867311\":\"des-types-au-top-2\"}]},\"description12867311\":\"Les types sont bien plus puissants que ce que peuvent nous laisser croire les types primitifs. Venez d√©couvrir avec moi les super pouvoirs des types !\",\"bannerAttribution\":[]}}}","3644372390":"{\"data\":{\"websiteConfiguration\":{\"name12867311\":\"JoGrenat's Blog\",\"youtubeChannelId12867311\":\"UCROJRWWGrrTmgGF1Wo9OX5w\",\"twitterIcon\":{\"url3832528868\":\"https://www.datocms-assets.com/53557/1632324226-twitterbird.svg\"},\"footerText12867311\":\"*Blog powered by [elm-pages](https://elm-pages.com/)*\"},\"_site\":{\"globalSeo\":{\"fallbackSeo\":{\"image\":{\"url1831060520\":\"https://www.datocms-assets.com/53557/1632838280-capture-d-ecran-2021-09-28-a-16-11-09.png?fit=fill&max-h=150&max-w=300\"}}}}}}"},"path":"blog/des-types-au-top"}